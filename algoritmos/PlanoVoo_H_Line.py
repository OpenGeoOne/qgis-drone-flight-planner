# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Flight Planner H Linear - Manually placed Side and Front distance data
                                 A QGIS plugin
 Flight Planner H Linear
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-11-21
        copyright            : (C) 2025 by Prof Cazaroli e Leandro França
        email                : contato@geoone.com.br
***************************************************************************/
"""

__author__ = 'Prof Cazaroli and Leandro França'
__date__ = '2025-11-21'
__copyright__ = '(C) 2025 by Prof Cazaroli and Leandro França'
__revision__ = '$Format:%H$'

from qgis.core import *
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.PyQt.QtWidgets import QAction, QMessageBox
from .Funcs import verificar_plugins, gerar_CSV, set_Z_value, reprojeta_camada_WGS84, simbologiaLinhaVoo, simbologiaPontos, verificarCRS, loadParametros, saveParametros, removeLayersReproj, arredondar_para_cima
from ..images.Imgs import *
import os

class PlanoVoo_H_Line(QgsProcessingAlgorithm):
    def initAlgorithm(self, config=None):
        hVooL, abGroundL, dlL, dfopL, dfL, velocL, tStayL, gimbalL, rasterL, csvL = loadParametros("H_Manual")

        self.addParameter(QgsProcessingParameterVectorLayer('linha', 'Axis_Line', types=[QgsProcessing.TypeVectorLine]))
        
        self.addParameter(QgsProcessingParameterNumber('altura','Flight Height (m)',
                                                       type=QgsProcessingParameterNumber.Double, minValue=2,defaultValue=hVooL))
        self.addParameter(QgsProcessingParameterBoolean('aboveGround', 'Above Ground (Follow Terrain)', defaultValue=abGroundL))
        
        self.addParameter(QgsProcessingParameterBoolean('incluir_eixo','Incluir fotos na linha eixo', defaultValue=True))

        self.addParameter(QgsProcessingParameterNumber('bf','Lateral Buffer (m)',
                                                       type=QgsProcessingParameterNumber.Double, minValue=0.5,defaultValue=dlL))

        frontal_opts = [self.tr('Distance (meters)'), self.tr('Time (seconds)')]
        self.addParameter(QgsProcessingParameterEnum('dfOpc', self.tr('Front Spacing Between Photos -- Options'), options = frontal_opts, defaultValue= dfopL))
        self.addParameter(QgsProcessingParameterNumber('df','Front Spacing Between Photos -- Value',
                                                       type=QgsProcessingParameterNumber.Double, minValue=1,defaultValue=dfL))

        self.addParameter(QgsProcessingParameterNumber('velocidade','Flight Speed (m/s)',
                                                       type=QgsProcessingParameterNumber.Double, minValue=1,maxValue=20,defaultValue=velocL))
        self.addParameter(QgsProcessingParameterNumber('tempo','Time to Wait for Photo (seconds)',
                                                       type=QgsProcessingParameterNumber.Integer, minValue=0,maxValue=10,defaultValue=tStayL))
        self.addParameter(QgsProcessingParameterNumber('gimbalAng','Gimbal Angle (degrees)',
                                                       type=QgsProcessingParameterNumber.Integer, minValue=-90, maxValue=70, defaultValue=gimbalL))
        self.addParameter(QgsProcessingParameterRasterLayer('raster','Input Raster (if any)', defaultValue=rasterL, optional=True))
        #self.addParameter(QgsProcessingParameterFolderDestination('saida_kml', 'Output Folder for kml (Google Earth)', defaultValue=skml, optional=True))
        self.addParameter(QgsProcessingParameterFileDestination('saida_csv', 'Output CSV File (Litchi)', fileFilter='CSV files (*.csv)', defaultValue=csvL))

    def processAlgorithm(self, parameters, context, feedback):
        teste = False # Quando True mostra camadas intermediárias

        # =====Parâmetros de entrada para variáveis==============================
        linha_layer = self.parameterAsVectorLayer(parameters, 'linha', context)
        if not linha_layer:
            raise QgsProcessingException("❌ Axis line layer is required.")
    
        camadaMDE = self.parameterAsRasterLayer(parameters, 'raster', context)

        H = parameters['altura']
        terrain = parameters['aboveGround']
        incluir_eixo = parameters['incluir_eixo']
        deltaLat = parameters['bf']          # Distância Buffer de voo paralelas - sem cálculo
        deltaFrontOpc = parameters['dfOpc']  # Em metros ou segundos
        deltaFront = parameters['df']        # Espaçamento Frontal entre as fotografias- sem cálculo
        velocidade = parameters['velocidade']
        tempo = parameters['tempo']
        gimbalAng = parameters['gimbalAng']
        raster_layer = self.parameterAsRasterLayer(parameters, 'raster', context)
        arquivo_csv = self.parameterAsFile(parameters, 'saida_csv', context)

        # ===== Verificações =====================================================
        # Verificar se as camadas estão salvas e fora da edição
        for lyr, nome in [(linha_layer, 'Axis_Line')]:
            if lyr.isEditable():
                raise QgsProcessingException(f"❌ Layer '{nome}' is in edit mode. Please save and exit editing before continuing.")
            
            # Detecta camada temporária ou não salva
            storage_type = lyr.dataProvider().storageType().lower()
            uri = lyr.dataProvider().dataSourceUri().lower()
            if storage_type == '' or 'memory:' in uri or '/temporary/' in uri:
                raise QgsProcessingException(f"❌ Layer '{nome}' is not saved. Save the layer to disk before using it.")

        # Verificar caminho das pastas
        if 'saida_csv' not in parameters:
            raise QgsProcessingException("❌ Path to CSV file is empty!")

        if arquivo_csv:
            if not os.path.exists(os.path.dirname(arquivo_csv)):
                raise QgsProcessingException("❌ Path to CSV file does not exist!")
            
        # Verificar as Geometrias
        if linha_layer.featureCount() != 1:
            raise QgsProcessingException("❌ The Axis must contain only one line.")
        
        # Verificar o SRC das Camadas
        crs = linha_layer.crs()

        if "UTM" in crs.description().upper():
            feedback.pushInfo(f"The layer 'Axis' is already in CRS UTM.")
        elif "WGS 84" in crs.description().upper() or "SIRGAS 2000" in crs.description().upper():
            crs = verificarCRS(linha_layer, feedback)
            nome = linha_layer.name() + "_reproject"
            linha_layer = QgsProject.instance().mapLayersByName(nome)[0]
        else:
            raise QgsProcessingException(f"❌ Layer must be WGS84 or SIRGAS2000 or UTM. Other ({crs.description().upper()}) not supported")
        
        linha_features = next(linha_layer.getFeatures()) # dados do Eixo (Axis)
        geom = linha_features.geometry()

        if geom.isEmpty():
            raise QgsProcessingException("❌ Axis geometry is empty.")
    
        # Grava Parâmetros
        saveParametros("H_Line",
                        h=parameters['altura'],
                        v=parameters['velocidade'],
                        t=parameters['tempo'],
                        gimbal=parameters['gimbalAng'],
                        raster=raster_layer.source() if raster_layer else "",
                        csv=arquivo_csv,
                        abGround=parameters['aboveGround'],
                        dl=parameters['bf'],
                        df=parameters['df'],
                        dfop=parameters['dfOpc'])

        # ===============================================================================
        # Normalizar para LineString
        def to_linestring(g: QgsGeometry) -> QgsGeometry:
            if g.isMultipart():
                ml = g.asMultiPolyline()
                if not ml:
                    # tentar converter multipart para single
                    g2 = g.convertToSingleType()
                    return g2 if g2.isGeosValid() else g
                # usar a parte mais longa
                longest = max(ml, key=lambda pts: QgsGeometry.fromPolylineXY([QgsPointXY(p.x(), p.y()) for p in pts]).length())
                return QgsGeometry.fromPolylineXY([QgsPointXY(p.x(), p.y()) for p in longest])
            # tentar como polyline simples
            pl = g.asPolyline()
            if pl:
                return QgsGeometry.fromPolylineXY([QgsPointXY(p.x(), p.y()) for p in pl])
            # fallback: tentar converter
            g2 = g.convertToSingleType()
            
            return g2 if not g2.isEmpty() else g

        linha_geom = to_linestring(geom)
        if linha_geom.isEmpty():
            raise QgsProcessingException("❌ Axis could not be converted to LineString.")

        # ===== Espaçamento lateral e frontal =====
        if deltaFrontOpc == 0:
            feedback.pushInfo(f"✅ Lateral spacing: {round(deltaLat, 2)} m, Front spacing: {round(deltaFront, 2)} m")
            spacing_m = deltaFront
        else:
            feedback.pushInfo(f"✅ Lateral spacing: {round(deltaLat, 2)} m, Front time: {round(deltaFront, 2)} s")
            spacing_m = velocidade * deltaFront  # distância = velocidade × tempo

        if spacing_m <= 0:
            raise QgsProcessingException("❌ Computed front spacing must be > 0.")

        # ===== Offsets laterais (direita/esquerda) =====
        # Nota: sinal do offsetCurve depende do sistema de coordenadas; usamos ±deltaLat e validamos
        linha_direita = linha_geom.offsetCurve(-deltaLat, segments=8, joinStyle=QgsGeometry.JoinStyleRound, miterLimit=2.0)
        linha_esquerda = linha_geom.offsetCurve(deltaLat, segments=8, joinStyle=QgsGeometry.JoinStyleRound, miterLimit=2.0)

        def valid_or_fallback(curve: QgsGeometry) -> QgsGeometry:
            if curve and not curve.isEmpty() and curve.isGeosValid():
                return to_linestring(curve)
            # se falhar, usa a própria linha como fallback
            return linha_geom

        linha_eixo = to_linestring(linha_geom)
        linha_direita = valid_or_fallback(linha_direita)
        linha_esquerda = valid_or_fallback(linha_esquerda)

        # ===== Geração de pontos ao longo das linhas =====
        def gerar_pontos(geom_line: QgsGeometry) -> list:
            comp = geom_line.length()
            if comp <= 0:
                return []
            # inclui o último ponto (extremidade)
            dist = 0.0
            pontos = []
            while dist < comp:
                pontos.append(geom_line.interpolate(dist))
                dist += spacing_m
            # garantir inclusão do fim da linha
            pontos.append(geom_line.interpolate(comp))
            return pontos

        pontos_direita = gerar_pontos(linha_direita)
        pontos_esquerda = gerar_pontos(linha_esquerda)

        pontos_eixo = []
        if incluir_eixo:
            pontos_eixo = gerar_pontos(linha_eixo)

        # ===== Ajuste de ordem (zig-zag) =====
        def inverter_se_necessario(pontos: list, ref_point: QgsGeometry) -> list:
            if not pontos or ref_point is None:
                return pontos
            dist_inicio = pontos[0].distance(ref_point)
            dist_fim = pontos[-1].distance(ref_point)
            if dist_fim < dist_inicio:
                pontos.reverse()
            return pontos
        
        if pontos_direita and pontos_eixo:
            pontos_eixo = inverter_se_necessario(pontos_eixo, pontos_direita[-1])
        if pontos_esquerda and pontos_eixo:
            pontos_esquerda = inverter_se_necessario(pontos_esquerda, pontos_eixo[-1])

        # ===== Camada de pontos (CRS igual ao da linha) =====
        authid = crs.authid() or ""
        if not authid:
            raise QgsProcessingException("❌ CRS authid not available for axis layer.")

        pontos_layer = QgsVectorLayer(f'Point?crs={authid}', 'Photo Points', 'memory')
        prov = pontos_layer.dataProvider()

        # Definir campos
        prov.addAttributes([
            QgsField("id", QVariant.Int),
            QgsField("latitude", QVariant.Double),
            QgsField("longitude", QVariant.Double),
            QgsField("altitude", QVariant.Double),
            QgsField("height", QVariant.Double)
        ])
        pontos_layer.updateFields()

        # ===== Criar features com numeração sequencial =====
        contador = 1
        transformador = QgsCoordinateTransform(pontos_layer.crs(), QgsCoordinateReferenceSystem('EPSG:4326'), QgsProject.instance())

        # ===== Criar sequência de pontos =====
        seq = []
        if pontos_direita:
            seq.append((pontos_direita, 'direita'))

        if incluir_eixo and pontos_eixo:
            seq.append((pontos_eixo, 'eixo'))

        if pontos_esquerda:
            # Se não incluir eixo, inverter esquerda para reduzir percurso
            if not incluir_eixo and pontos_direita and pontos_esquerda:
                dist_inicio = pontos_esquerda[0].distance(pontos_direita[-1])
                dist_fim = pontos_esquerda[-1].distance(pontos_direita[-1])
                if dist_fim < dist_inicio:
                    pontos_esquerda.reverse()
            seq.append((pontos_esquerda, 'esquerda'))

        # ===== Criar features com numeração sequencial =====
        contador = 1
        transformador = QgsCoordinateTransform(pontos_layer.crs(), QgsCoordinateReferenceSystem('EPSG:4326'), QgsProject.instance())

        for lista, tipo in seq:
            for ponto in lista:
                if not ponto or ponto.isEmpty():
                    continue
                geom = ponto.asPoint()
                geom_utm = QgsGeometry.fromPointXY(QgsPointXY(geom.x(), geom.y()))
                geom_wgs = transformador.transform(QgsPointXY(geom.x(), geom.y()))

                f = QgsFeature()
                f.setGeometry(geom_utm)
                f.setAttributes([
                    contador,
                    geom_wgs.y(),   # latitude
                    geom_wgs.x(),   # longitude
                    None,           # altitude será preenchida depois
                    H               # height (altura de voo)
                ])
                prov.addFeature(f)
                contador += 1

        pontos_layer.updateExtents()
        feedback.pushInfo(f"✅ {contador-1} Photo Points generated.")

        # ===== Obter altitude do MDE se fornecido =====
        if camadaMDE:
            transformadorMDE = QgsCoordinateTransform(pontos_layer.crs(), camadaMDE.crs(), QgsProject.instance())
            
            pontos_layer.startEditing()

            for f in pontos_layer.getFeatures():
                point = f.geometry().asPoint()
                point_transf = transformadorMDE.transform(QgsPointXY(point.x(), point.y()))
                value, result = camadaMDE.dataProvider().sample(point_transf, 1)

                if result:
                    f["altitude"] = value + H
                    f["height"] = H
                    pontos_layer.updateFeature(f)   
                else:
                    f["height"] = H
                    pontos_layer.updateFeature(f)
                    feedback.pushInfo(f"⚠️ Ponto {f['id']} fora da extensão do MDE")
            
            pontos_layer.commitChanges()

        # ===== Reprojetar para WGS84 e aplicar Z =====
        crs_wgs = QgsCoordinateReferenceSystem('EPSG:4326')
        pontos_reproj = reprojeta_camada_WGS84(pontos_layer, crs_wgs, transformador)

        if camadaMDE:
            pontos_reproj = set_Z_value(pontos_reproj, z_field="altitude")
        else:
            pontos_reproj = set_Z_value(pontos_reproj, z_field="height")

        # ===== Rotulagem e simbologia =====
        simbologiaPontos(pontos_reproj)

        # ===== Mostra a camada Pontos de Fotos criada =====
        QgsProject.instance().addMapLayer(pontos_reproj)

        feedback.pushInfo("")
        feedback.pushInfo("✅ Flight Line and Photo Spots completed.")
        """"
        # =============L I T C H I==========================================================

        feedback.pushInfo("")

        if arquivo_csv and arquivo_csv.endswith('.csv'): # Verificar se o caminho CSV está preenchido
            gerar_CSV("H", pontos_reproj, arquivo_csv, velocidade, tempo, arredondar_para_cima(deltaFront, 2), 360, H, gimbalAng, terrain, deltaFrontOpc)

            feedback.pushInfo("✅ CSV file successfully generated.")
        else:
            feedback.pushInfo("❌ CSV path not specified. Export step skipped.")

        """
        # ============= Mensagem de Encerramento =====================================================
        feedback.pushInfo("")
        feedback.pushInfo("✅ Horizontal Flight Plan successfully executed.")
        feedback.pushInfo("")
        
        return {}

    def name(self):
        return 'Flight_Plan_H_Line'

    def displayName(self):
        return self.tr('4.Following terrain - Line')

    def group(self):
        return 'Horizontal Flight'

    def groupId(self):
        return 'horizontal'
    
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return PlanoVoo_H_Line()

    def tags(self):
        return self.tr('Flight Plan,Measure,Topography,Plano voo,Plano de voo,voo,drone,GeoOne').split(',')

    def icon(self):
        return QIcon(os.path.join(os.path.dirname(os.path.dirname(__file__)), 'images/Horizontal.png'))

    texto = """This tool enables drone flight planning for photogrammetry, following terrain elevations (optionally), and lateral and frontal overlaps are entered. And you can also choose the photo interval by <b>distance</b> or by <b>time</b>.</b><br>
It generates <b>CSV</b> file compatible with the <b>Litchi app</b> and 2 Layers - <b>Flight Line</b> and <b>Photos Points</b>.
<p>It can also be used with other flight applications, utilizing the 2 genereted Layers for flight lines and waypoints.</p>
<p><b>Learn more:</b><o:p></o:p></p>
<ul style="margin-top: 0cm;" type="disc">
   <li><a href="https://geoone.com.br/pvplanodevoo">Sign up for GeoFlight Planner course</a><o:p></o:p></li>
   <li><a href="https://portal.geoone.com.br/m/lessons/planodevoo?classId=5680">Click here to access the class with all the details about this tool!</a><o:p></o:p></li>
</ul>
<p><b>Tips:</b><o:p></o:p></p>
<ul style="margin-top: 0cm;" type="disc">
  <li><a href="https://geoone.com.br/plano-de-voo-para-drone-com-python/#sensor">Check your drone sensor parameters</a><o:p></o:p></li>
  <li><a href="https://geoone.com.br/opentopography-qgis/">Obtain the MDE for the Open Topography plugin</a><o:p></o:p></span></li>
</ul>
"""

    figura2 = 'images/Terrain_Follow.jpg'

    def shortHelpString(self):
        corpo = '''<div align="center">
                      <img src="'''+ os.path.join(os.path.dirname(os.path.dirname(__file__)), self.figura2) +'''">
                      </div>
                      <div align="right">
                      <p align="right">
                      <b>Autores: Prof Cazaroli & Leandro França</b>
                      </p>
                      <a target="_blank" rel="noopener noreferrer" href="https://geoone.com.br/"><img title="GeoOne" src="data:image/png;base64,'''+ GeoOne +'''"></a>
					  <p><i>"Automated, easy and straight to the point mapping is at GeoOne!"</i></p>
                      </div>
                    </div>'''
        return self.tr(self.texto) + corpo
