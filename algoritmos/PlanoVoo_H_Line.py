# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Flight Planner H Linear - Manually placed Side and Front distance data
                                 A QGIS plugin
 Flight Planner H Linear
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-11-21
        copyright            : (C) 2025 by Prof Cazaroli e Leandro França
        email                : contato@geoone.com.br
***************************************************************************/
"""

__author__ = 'Prof Cazaroli and Leandro França'
__date__ = '2025-11-21'
__copyright__ = '(C) 2025 by Prof Cazaroli and Leandro França'
__revision__ = '$Format:%H$'

from qgis.core import *
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.PyQt.QtWidgets import QAction, QMessageBox
from .Funcs import verificar_plugins, gerar_CSV, set_Z_value, reprojeta_camada_WGS84, simbologiaLinhaVoo, simbologiaPontos, verificarCRS, loadParametros, saveParametros, removeLayersReproj, arredondar_para_cima
from ..images.Imgs import *
import os

class PlanoVoo_H_Line(QgsProcessingAlgorithm):
    def initAlgorithm(self, config=None):
        hVooL, abGroundL, dlL, dfopL, dfL, velocL, tStayL, gimbalL, rasterL, csvL = loadParametros("H_Manual")

        self.addParameter(QgsProcessingParameterVectorLayer('linha', 'Axis_Line', types=[QgsProcessing.TypeVectorLine]))
        
        self.addParameter(QgsProcessingParameterNumber('altura','Flight Height (m)',
                                                       type=QgsProcessingParameterNumber.Double, minValue=2,defaultValue=hVooL))
        self.addParameter(QgsProcessingParameterBoolean('aboveGround', 'Above Ground (Follow Terrain)',defaultValue=abGroundL))
        
        self.addParameter(QgsProcessingParameterBoolean('incluir_eixo','Include photos on the center line',defaultValue=True))

        self.addParameter(QgsProcessingParameterBoolean('dois_buffers','Use two buffers (left and right)',defaultValue=False))
        
        self.addParameter(QgsProcessingParameterNumber('bf','Lateral Buffer (m)',
                                                       type=QgsProcessingParameterNumber.Double, minValue=0.5,defaultValue=dlL))

        frontal_opts = [self.tr('Distance (meters)'), self.tr('Time (seconds)')]
        self.addParameter(QgsProcessingParameterEnum('dfOpc', self.tr('Front Spacing Between Photos -- Options'), options = frontal_opts, defaultValue= dfopL))
        self.addParameter(QgsProcessingParameterNumber('df','Front Spacing Between Photos -- Value',
                                                       type=QgsProcessingParameterNumber.Double, minValue=1,defaultValue=dfL))

        self.addParameter(QgsProcessingParameterNumber('velocidade','Flight Speed (m/s)',
                                                       type=QgsProcessingParameterNumber.Double, minValue=1,maxValue=20,defaultValue=velocL))
        self.addParameter(QgsProcessingParameterNumber('tempo','Time to Wait for Photo (seconds)',
                                                       type=QgsProcessingParameterNumber.Integer, minValue=0,maxValue=10,defaultValue=tStayL))
        self.addParameter(QgsProcessingParameterNumber('gimbalAng','Gimbal Angle (degrees)',
                                                       type=QgsProcessingParameterNumber.Integer, minValue=-90, maxValue=70, defaultValue=gimbalL))
        self.addParameter(QgsProcessingParameterRasterLayer('raster','Input Raster (if any)', defaultValue=rasterL, optional=True))
        #self.addParameter(QgsProcessingParameterFolderDestination('saida_kml', 'Output Folder for kml (Google Earth)', defaultValue=skml, optional=True))
        self.addParameter(QgsProcessingParameterFileDestination('saida_csv', 'Output CSV File (Litchi)', fileFilter='CSV files (*.csv)', defaultValue=csvL))

    def processAlgorithm(self, parameters, context, feedback):
        teste = False # Quando True mostra camadas intermediárias

        # =====Parâmetros de entrada para variáveis==============================
        linha_layer = self.parameterAsVectorLayer(parameters, 'linha', context)
        if not linha_layer:
            raise QgsProcessingException("❌ Axis line layer is required.")
    
        camadaMDE = self.parameterAsRasterLayer(parameters, 'raster', context)

        H = parameters['altura']
        terrain = parameters['aboveGround']
        incluir_eixo = parameters['incluir_eixo']
        dois_buffers = parameters['dois_buffers'] # se for False terá um Buffer só
        deltaLat = parameters['bf']          # Distância Buffer de voo paralelas - sem cálculo
        deltaFrontOpc = parameters['dfOpc']  # Em metros ou segundos
        deltaFront = parameters['df']        # Espaçamento Frontal entre as fotografias- sem cálculo
        velocidade = parameters['velocidade']
        tempo = parameters['tempo']
        gimbalAng = parameters['gimbalAng']
        raster_layer = self.parameterAsRasterLayer(parameters, 'raster', context)
        arquivo_csv = self.parameterAsFile(parameters, 'saida_csv', context)

        # ===== Verificações =====================================================
        # Verificar se as camadas estão salvas e fora da edição
        for lyr, nome in [(linha_layer, 'Axis_Line')]:
            if lyr.isEditable():
                raise QgsProcessingException(f"❌ Layer '{nome}' is in edit mode. Please save and exit editing before continuing.")
            
            # Detecta camada temporária ou não salva
            storage_type = lyr.dataProvider().storageType().lower()
            uri = lyr.dataProvider().dataSourceUri().lower()
            if storage_type == '' or 'memory:' in uri or '/temporary/' in uri:
                raise QgsProcessingException(f"❌ Layer '{nome}' is not saved. Save the layer to disk before using it.")

        # Verificar caminho das pastas
        if 'saida_csv' not in parameters:
            raise QgsProcessingException("❌ Path to CSV file is empty!")

        if arquivo_csv:
            if not os.path.exists(os.path.dirname(arquivo_csv)):
                raise QgsProcessingException("❌ Path to CSV file does not exist!")
            
        # Verificar as Geometrias
        if linha_layer.featureCount() != 1:
            raise QgsProcessingException("❌ The Axis must contain only one line.")
        
        # Verificar o SRC das Camadas
        crs = linha_layer.crs()

        if "UTM" in crs.description().upper():
            feedback.pushInfo(f"The layer 'Axis' is already in CRS UTM.")
        elif "WGS 84" in crs.description().upper() or "SIRGAS 2000" in crs.description().upper():
            crs = verificarCRS(linha_layer, feedback)
            nome = linha_layer.name() + "_reproject"
            linha_layer = QgsProject.instance().mapLayersByName(nome)[0]
        else:
            raise QgsProcessingException(f"❌ Layer must be WGS84 or SIRGAS2000 or UTM. Other ({crs.description().upper()}) not supported")
        
        linha_features = next(linha_layer.getFeatures()) # dados do Eixo (Axis)
        geom = linha_features.geometry()

        if geom.isEmpty():
            raise QgsProcessingException("❌ Axis geometry is empty.")
    
        # Grava Parâmetros
        saveParametros("H_Line",
                        h=parameters['altura'],
                        v=parameters['velocidade'],
                        t=parameters['tempo'],
                        gimbal=parameters['gimbalAng'],
                        raster=raster_layer.source() if raster_layer else "",
                        csv=arquivo_csv,
                        abGround=parameters['aboveGround'],
                        dl=parameters['bf'],
                        df=parameters['df'],
                        dfop=parameters['dfOpc'])

        # ===============================================================================
        # Normalizar para LineString
        def to_linestring(g: QgsGeometry) -> QgsGeometry:
            if g.isMultipart():
                ml = g.asMultiPolyline()
                if ml:
                    longest = max(ml, key=lambda pts: QgsGeometry.fromPolylineXY([QgsPointXY(p.x(), p.y()) for p in pts]).length())
                    return QgsGeometry.fromPolylineXY([QgsPointXY(p.x(), p.y()) for p in longest])
            pl = g.asPolyline()
            if pl:
                return QgsGeometry.fromPolylineXY([QgsPointXY(p.x(), p.y()) for p in pl])
            return g.convertToSingleType()

        linha_geom = to_linestring(geom)

        # ===== Espaçamento frontal =====
        if deltaFrontOpc == 0:
            spacing_m = deltaFront
        else:
            spacing_m = velocidade * deltaFront
        if spacing_m <= 0:
            raise QgsProcessingException("❌ Computed front spacing must be > 0.")

        # ===== Offsets laterais (direita/esquerda) =====
        linha_direita1 = linha_geom.offsetCurve(-deltaLat, segments=8, joinStyle=QgsGeometry.JoinStyleRound, miterLimit=2.0)
        linha_esquerda1 = linha_geom.offsetCurve(deltaLat, segments=8, joinStyle=QgsGeometry.JoinStyleRound, miterLimit=2.0)

        def valid_or_fallback(curve: QgsGeometry) -> QgsGeometry:
            if curve and not curve.isEmpty() and curve.isGeosValid():
                return to_linestring(curve)
            return linha_geom

        linha_direita1 = valid_or_fallback(linha_direita1)
        linha_esquerda1 = valid_or_fallback(linha_esquerda1)

        linha_direita2 = None
        linha_esquerda2 = None
        if dois_buffers:
            linha_direita2 = valid_or_fallback(linha_geom.offsetCurve(-2*deltaLat, segments=8, joinStyle=QgsGeometry.JoinStyleRound, miterLimit=2.0))
            linha_esquerda2 = valid_or_fallback(linha_geom.offsetCurve(2*deltaLat, segments=8, joinStyle=QgsGeometry.JoinStyleRound, miterLimit=2.0))

        # ===== Geração de pontos ao longo das linhas =====
        def gerar_pontos(geom_line: QgsGeometry) -> list:
            comp = geom_line.length()
            dist = 0.0
            pontos = []
            while dist < comp:
                pontos.append(geom_line.interpolate(dist))
                dist += spacing_m
            pontos.append(geom_line.interpolate(comp))
            return pontos

        pontos_direita1 = gerar_pontos(linha_direita1)
        pontos_esquerda1 = gerar_pontos(linha_esquerda1)
        pontos_direita2 = gerar_pontos(linha_direita2) if dois_buffers else []
        pontos_esquerda2 = gerar_pontos(linha_esquerda2) if dois_buffers else []
        pontos_eixo = gerar_pontos(linha_geom) if incluir_eixo else []

        # ===== Ajuste de ordem (reverse) =====
        def ajustar_ordem(pontos_atual, pontos_anterior):
            if not pontos_atual or not pontos_anterior:
                return pontos_atual
            dist_inicio = pontos_atual[0].distance(pontos_anterior[-1])
            dist_fim = pontos_atual[-1].distance(pontos_anterior[-1])
            if dist_fim < dist_inicio:
                pontos_atual.reverse()
            return pontos_atual

        if pontos_direita2:
            pontos_direita2 = ajustar_ordem(pontos_direita2, pontos_direita1)
        if pontos_eixo:
            pontos_eixo = ajustar_ordem(pontos_eixo, pontos_direita2 if pontos_direita2 else pontos_direita1)
        if pontos_esquerda1:
            pontos_esquerda1 = ajustar_ordem(pontos_esquerda1, pontos_eixo if pontos_eixo else (pontos_direita2 if pontos_direita2 else pontos_direita1))
        if pontos_esquerda2:
            pontos_esquerda2 = ajustar_ordem(pontos_esquerda2, pontos_esquerda1)

        # ===== Camada de pontos =====
        pontos_layer = QgsVectorLayer(f'Point?crs={crs.authid()}', 'Photo Points', 'memory')
        prov = pontos_layer.dataProvider()
        prov.addAttributes([
            QgsField("id", QVariant.Int),
            QgsField("latitude", QVariant.Double),
            QgsField("longitude", QVariant.Double),
            QgsField("altitude", QVariant.Double),
            QgsField("height", QVariant.Double)
        ])
        pontos_layer.updateFields()

        # ===== Criar features =====
        contador = 1
        transformador = QgsCoordinateTransform(pontos_layer.crs(), QgsCoordinateReferenceSystem('EPSG:4326'), QgsProject.instance())

        # ===== Função para ajustar ordem entre linhas =====
        def ajustar_ordem(pontos_atual, pontos_anterior):
            if not pontos_atual or not pontos_anterior:
                return pontos_atual
            dist_inicio = pontos_atual[0].distance(pontos_anterior[-1])
            dist_fim = pontos_atual[-1].distance(pontos_anterior[-1])
            if dist_fim < dist_inicio:
                pontos_atual.reverse()
            return pontos_atual

        # ===== Determinar lado inicial da linha-eixo =====
        linha_pts = linha_geom.asPolyline()
        inicio = QgsPointXY(linha_pts[0])
        fim = QgsPointXY(linha_pts[-1])

        # Usamos o vetor inicial para decidir se começamos pela direita ou esquerda
        # (simplificação: sempre começar pela direita; se quiser inverter, basta trocar)
        comeca_direita = True

        # ===== Construir sequência =====
        seq = []

        if dois_buffers:
            if comeca_direita:
                # começa pela direita mais extrema
                if pontos_direita2:
                    seq.append((pontos_direita2, 'direita2'))
                if pontos_direita1:
                    pontos_direita1 = ajustar_ordem(pontos_direita1, seq[-1][0])
                    seq.append((pontos_direita1, 'direita1'))
            else:
                # começa pela esquerda mais extrema
                if pontos_esquerda2:
                    seq.append((pontos_esquerda2, 'esquerda2'))
                if pontos_esquerda1:
                    pontos_esquerda1 = ajustar_ordem(pontos_esquerda1, seq[-1][0])
                    seq.append((pontos_esquerda1, 'esquerda1'))
        else:
            # um buffer: começa direto no lado inicial (já estava correto)
            if comeca_direita and pontos_direita1:
                seq.append((pontos_direita1, 'direita1'))
            elif pontos_esquerda1:
                seq.append((pontos_esquerda1, 'esquerda1'))

        # Depois continua zig-zag normalmente:
        if incluir_eixo and pontos_eixo:
            pontos_eixo = ajustar_ordem(pontos_eixo, seq[-1][0])
            seq.append((pontos_eixo, 'eixo'))

        # adiciona o lado oposto
        if comeca_direita:
            if pontos_esquerda1:
                pontos_esquerda1 = ajustar_ordem(pontos_esquerda1, seq[-1][0])
                seq.append((pontos_esquerda1, 'esquerda1'))
            if pontos_esquerda2:
                pontos_esquerda2 = ajustar_ordem(pontos_esquerda2, seq[-1][0])
                seq.append((pontos_esquerda2, 'esquerda2'))
        else:
            if pontos_direita1:
                pontos_direita1 = ajustar_ordem(pontos_direita1, seq[-1][0])
                seq.append((pontos_direita1, 'direita1'))
            if pontos_direita2:
                pontos_direita2 = ajustar_ordem(pontos_direita2, seq[-1][0])
                seq.append((pontos_direita2, 'direita2'))

        # ===== Inserir features numeradas =====
        for lista, tipo in seq:
            for ponto in lista:
                if not ponto or ponto.isEmpty():
                    continue
                geom = ponto.asPoint()
                geom_utm = QgsGeometry.fromPointXY(QgsPointXY(geom.x(), geom.y()))
                geom_wgs = transformador.transform(QgsPointXY(geom.x(), geom.y()))

                f = QgsFeature()
                f.setGeometry(geom_utm)
                f.setAttributes([
                    contador,
                    geom_wgs.y(),   # latitude
                    geom_wgs.x(),   # longitude
                    None,           # altitude preenchida depois
                    H               # height (altura de voo)
                ])
                prov.addFeature(f)
                contador += 1

        pontos_layer.updateExtents()
        feedback.pushInfo(f"✅ {contador-1} Photo Points generated.")
        
        # ===== Altitude via MDE =====
        if camadaMDE:
            transformadorMDE = QgsCoordinateTransform(pontos_layer.crs(), camadaMDE.crs(), QgsProject.instance())
            pontos_layer.startEditing()
            for f in pontos_layer.getFeatures():
                pt = f.geometry().asPoint()
                pt_transf = transformadorMDE.transform(QgsPointXY(pt.x(), pt.y()))
                value, result = camadaMDE.dataProvider().sample(pt_transf, 1)
                if result:
                    f["altitude"] = value + H
                    f["height"] = H
                    pontos_layer.updateFeature(f)
            pontos_layer.commitChanges()

        # ===== Reprojetar para WGS84 e aplicar Z =====
        crs_wgs = QgsCoordinateReferenceSystem('EPSG:4326')
        pontos_reproj = reprojeta_camada_WGS84(pontos_layer, crs_wgs, transformador)

        if camadaMDE:
            pontos_reproj = set_Z_value(pontos_reproj, z_field="altitude")
        else:
            pontos_reproj = set_Z_value(pontos_reproj, z_field="height")

        # ===== Rotulagem e simbologia =====
        simbologiaPontos(pontos_reproj)

        # ===== Mostra a camada Pontos de Fotos criada =====
        QgsProject.instance().addMapLayer(pontos_reproj)

        feedback.pushInfo("")
        feedback.pushInfo("✅ Flight Line and Photo Spots completed.")
        """"
        # =============L I T C H I==========================================================

        feedback.pushInfo("")

        if arquivo_csv and arquivo_csv.endswith('.csv'): # Verificar se o caminho CSV está preenchido
            gerar_CSV("H", pontos_reproj, arquivo_csv, velocidade, tempo, arredondar_para_cima(deltaFront, 2), 360, H, gimbalAng, terrain, deltaFrontOpc)

            feedback.pushInfo("✅ CSV file successfully generated.")
        else:
            feedback.pushInfo("❌ CSV path not specified. Export step skipped.")

        """
        # ============= Mensagem de Encerramento =====================================================
        feedback.pushInfo("")
        feedback.pushInfo("✅ Horizontal Flight Plan successfully executed.")
        feedback.pushInfo("")
        
        return {}

    def name(self):
        return 'Flight_Plan_H_Line'

    def displayName(self):
        return self.tr('4.Following terrain - Line')

    def group(self):
        return 'Horizontal Flight'

    def groupId(self):
        return 'horizontal'
    
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return PlanoVoo_H_Line()

    def tags(self):
        return self.tr('Flight Plan,Measure,Topography,Plano voo,Plano de voo,voo,drone,GeoOne').split(',')

    def icon(self):
        return QIcon(os.path.join(os.path.dirname(os.path.dirname(__file__)), 'images/Horizontal.png'))

    texto = """This tool enables drone flight planning for photogrammetry, following terrain elevations (optionally), and lateral and frontal overlaps are entered. And you can also choose the photo interval by <b>distance</b> or by <b>time</b>.</b><br>
It generates <b>CSV</b> file compatible with the <b>Litchi app</b> and 2 Layers - <b>Flight Line</b> and <b>Photos Points</b>.
<p>It can also be used with other flight applications, utilizing the 2 genereted Layers for flight lines and waypoints.</p>
<p><b>Learn more:</b><o:p></o:p></p>
<ul style="margin-top: 0cm;" type="disc">
   <li><a href="https://geoone.com.br/pvplanodevoo">Sign up for GeoFlight Planner course</a><o:p></o:p></li>
   <li><a href="https://portal.geoone.com.br/m/lessons/planodevoo?classId=5680">Click here to access the class with all the details about this tool!</a><o:p></o:p></li>
</ul>
<p><b>Tips:</b><o:p></o:p></p>
<ul style="margin-top: 0cm;" type="disc">
  <li><a href="https://geoone.com.br/plano-de-voo-para-drone-com-python/#sensor">Check your drone sensor parameters</a><o:p></o:p></li>
  <li><a href="https://geoone.com.br/opentopography-qgis/">Obtain the MDE for the Open Topography plugin</a><o:p></o:p></span></li>
</ul>
"""

    figura2 = 'images/Terrain_Follow.jpg'

    def shortHelpString(self):
        corpo = '''<div align="center">
                      <img src="'''+ os.path.join(os.path.dirname(os.path.dirname(__file__)), self.figura2) +'''">
                      </div>
                      <div align="right">
                      <p align="right">
                      <b>Autores: Prof Cazaroli & Leandro França</b>
                      </p>
                      <a target="_blank" rel="noopener noreferrer" href="https://geoone.com.br/"><img title="GeoOne" src="data:image/png;base64,'''+ GeoOne +'''"></a>
					  <p><i>"Automated, easy and straight to the point mapping is at GeoOne!"</i></p>
                      </div>
                    </div>'''
        return self.tr(self.texto) + corpo
