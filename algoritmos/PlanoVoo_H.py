# -*- coding: utf-8 -*-

"""
/***************************************************************************
 PlanoVoo
                                 A QGIS plugin
 PlanoVoo
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-05
        copyright            : (C) 2024 by Prof Cazaroli e Leandro França
        email                : contato@geoone.com.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Prof Cazaroli e Leandro França'
__date__ = '2024-11-05'
__copyright__ = '(C) 2024 by Prof Cazaroli e Leandro França'
__revision__ = '$Format:%H$'

from qgis.core import *
from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtGui import QIcon
from PyQt5.QtCore import QVariant
from qgis.PyQt.QtWidgets import QAction, QMessageBox
from .Funcs import verificar_plugins, obter_DEM, gerar_KML, gerar_CSV, set_Z_value, reprojeta_camada_WGS84, simbologiaLinhaVoo, simbologiaPontos
import processing
import os
import math
import csv

# pontos_provider Air 2S (5472 × 3648)

class PlanoVoo_H(QgsProcessingAlgorithm):
    def initAlgorithm(self, config=None):
        my_settings = QgsSettings()
        try:
            api_key = my_settings.value("OpenTopographyDEMDownloader/ot_api_key", "")
        except:
            api_key = ''

        self.addParameter(QgsProcessingParameterVectorLayer('terreno', 'Area', types=[QgsProcessing.TypeVectorPolygon]))
        self.addParameter(QgsProcessingParameterVectorLayer('primeira_linha','First line - direction flight', types=[QgsProcessing.TypeVectorLine]))
        self.addParameter(QgsProcessingParameterNumber('H','Flight Height (m)',
                                                       type=QgsProcessingParameterNumber.Integer, minValue=50,defaultValue=100))
        self.addParameter(QgsProcessingParameterNumber('dc','Sensor: Horizontal Size (m)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0,defaultValue=13.2e-3)) # igual p/o Phantom 4 Pro e Air 2S (5472 × 3648)
        self.addParameter(QgsProcessingParameterNumber('dl','Sensor: Vertical Size (m)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0,defaultValue=8.8e-3)) # igual p/o Phantom 4 Pro e Air 2S (5472 × 3648)
        self.addParameter(QgsProcessingParameterNumber('f','Sensor: Focal Length (m)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0,defaultValue=8.38e-3)) # Para o Air 2S - Phantom 4 Pro é f = 9e-3
        self.addParameter(QgsProcessingParameterNumber('percL','Side Overlap (75% = 0.75)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0.60,defaultValue=0.75))
        self.addParameter(QgsProcessingParameterNumber('percF','Forward Overlap (85% = 0.85)',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       minValue=0.60,defaultValue=0.85))
        self.addParameter(QgsProcessingParameterString('api_key', 'API key - OpenTopography plugin',defaultValue=api_key))
        self.addParameter(QgsProcessingParameterNumber('velocidade','Flight Speed (m/s)',
                                                       type=QgsProcessingParameterNumber.Double, minValue=2,defaultValue=8))
        self.addParameter(QgsProcessingParameterNumber('tempo','Time to Wait for Photo (seconds)',
                                                       type=QgsProcessingParameterNumber.Integer, minValue=0,defaultValue=0))
        self.addParameter(QgsProcessingParameterFolderDestination('saida_kml', 'Output Folder for KML (Google Earth)'))
        self.addParameter(QgsProcessingParameterFileDestination('saida_csv', 'Output CSV File (Litchi)',
                                                               fileFilter='CSV files (*.csv)'))

    def processAlgorithm(self, parameters, context, feedback):
        teste = False # Quando True mostra camadas intermediárias

        # =====Parâmetros de entrada para variáveis==============================
        area_layer = self.parameterAsVectorLayer(parameters, 'terreno', context)
        crs = area_layer.crs()

        primeira_linha  = self.parameterAsVectorLayer(parameters, 'primeira_linha', context)

        apikey = parameters['api_key']

        H = parameters['H']
        dc = parameters['dc']
        dl = parameters['dl']
        f = parameters['f']
        percL = parameters['percL'] # Lateral
        percF = parameters['percF'] # Frontal
        velocidade = parameters['velocidade']
        tempo = parameters['tempo']

        caminho_kml = parameters['saida_kml']
        arquivo_csv = parameters['saida_csv']

        # ===== Verificações =====================================================

        # Verificar se os plugins estão instalados
        plugins_verificar = ["OpenTopography-DEM-Downloader", "lftools", "kmltools"]
        verificar_plugins(plugins_verificar, feedback)

        # Verificar se o polígono e a primeira_linha contém exatamente uma feature
        poligono_features = list(area_layer.getFeatures()) # dados do Terreno
        if len(poligono_features) != 1:
            raise ValueError("The Area must contain only one polygon.")

        linha_features = list(primeira_linha.getFeatures())
        if len(linha_features) != 1:
            raise ValueError("The First Line must contain only one line.")

         # =====Cálculo das Sobreposições=========================================
        # Distância das linhas de voo paralelas - Espaçamento Lateral
        tg_alfa_2 = dc / (2 * f)
        D_lat = dc * H / f
        SD_lat = percL * D_lat
        h1 = SD_lat / (2 * tg_alfa_2)
        deltaLat = SD_lat * (H / h1 - 1)

        # Espaçamento Frontal entre as fotografias- Espaçamento Frontal
        tg_alfa_2 = dl / (2 * f)
        D_front = dl * H / f
        SD_front = percF * D_front
        h1 = SD_front / (2 * tg_alfa_2)
        deltaFront = SD_front * (H / h1 - 1)

        feedback.pushInfo(f"Lateral Spacing: {round(deltaLat,2)}, Frontal Spacing: {round(deltaFront,2)}")

        # =====================================================================
        # ===== OpenTopography ================================================

        # Reprojetar para WGS 84 (EPSG:4326), usado pelo OpenTopography
        crs_wgs = QgsCoordinateReferenceSystem(4326)
        transformador = QgsCoordinateTransform(crs, crs_wgs, QgsProject.instance())

        camadaMDE = obter_DEM("H", area_layer, transformador, apikey, feedback)

        #QgsProject.instance().addMapLayer(camadaMDE)

        #camadaMDE = QgsProject.instance().mapLayersByName("DEM")[0]

        # ================================================================================
        # ===== Ajuste da linha sobre um lado do polígono ================================

        poligono_features = next(area_layer.getFeatures())
        poligono_geom = poligono_features.geometry()

        linha_features = next(primeira_linha.getFeatures())
        linha_geom = linha_features.geometry()

        # Verificar se o polígono é multipart ou simples
        if poligono_geom.isMultipart():
            p = poligono_geom.asMultiPolygon()[0][0]  # Primeiro polígono
        else:
            p = poligono_geom.asPolygon()[0]  # Polígono simples

        # Criar lista de arestas (pares de vértices consecutivos)
        bordas = [(p[i], p[i + 1]) for i in range(len(p) - 1)]

        # Encontrar o ponto inicial da linha
        if linha_geom.isMultipart():
            linha_base = linha_geom.asMultiPolyline()[0]  # Primeira linha em multipart
        else:
            linha_base = linha_geom.asPolyline()  # Linha simples

        # Calcular direção da linha base (comparar o ponto inicial e final)
        x1_base, y1_base = linha_base[0]
        x2_base, y2_base = linha_base[-1]

        direcao_base = 'direita' if x2_base > x1_base or (x2_base == x1_base and y2_base > y1_base) else 'esquerda'

        # Verificar se a linha base coincide com algum lado do polígono
        linha_base_geom = QgsGeometry.fromPolylineXY(linha_base)

        tolerancia = 0.01
        coincide_com_borda = False

        for v1, v2 in bordas:
            borda_geom = QgsGeometry.fromPolylineXY([v1, v2])

            # Calcular a distância entre a linha base e a borda
            distancia = borda_geom.shortestLine(linha_geom).length()

            # Verificar se a linha base coincide com a borda
            if distancia <= tolerancia:
                coincide_com_borda = True
                break

        if not coincide_com_borda:
            # Encontrar a aresta mais próxima da linha
            min_distancia = float('inf')
            closest_borda = None

            for v1, v2 in bordas:
                borda_geom = QgsGeometry.fromPolylineXY([v1, v2])
                distancia = borda_geom.shortestLine(linha_geom).length()

                if distancia < min_distancia:
                    min_distancia = distancia
                    closest_borda = borda_geom

            # Atualizar a posição da Linha Base
            nova_linha_geom = QgsGeometry.fromPolylineXY(closest_borda.asPolyline())

            with edit(primeira_linha):
                primeira_linha.changeGeometry(linha_features.id(), nova_linha_geom)

            # Encontrar o ponto inicial da linha deslocada
            linha_features = next(primeira_linha.getFeatures())
            linha_geom = linha_features.geometry()

            if linha_geom.isMultipart():
                linha_base = linha_geom.asMultiPolyline()[0]  # Primeira linha em multipart
            else:
                linha_base = linha_geom.asPolyline()  # Linha simples

            # Calcular a direção da linha deslocada
            x1, y1 = linha_base[0]
            x2, y2 = linha_base[-1]

            direcao_deslocada = 'direita' if x2 > x1 or (x2 == x1 and y2 > y1) else 'esquerda'

            # Inverter a linha deslocada se as direções forem diferentes
            if direcao_base != direcao_deslocada:
                # Inverter a linha deslocada
                nova_linha_geom_invertida = QgsGeometry.fromPolylineXY(list(reversed(nova_linha_geom.asPolyline())))

                with edit(primeira_linha):
                    primeira_linha.changeGeometry(linha_features.id(), nova_linha_geom_invertida)

        # =====================================================================
        # ===== Determinação das Linhas de Voo ================================

        linha_features = next(primeira_linha.getFeatures())
        linha_geom = linha_features.geometry()

        vertices = [QgsPointXY(v) for v in poligono_geom.vertices()] # Extrair os vértices do polígono

        if linha_geom.isMultipart():
            linha_vertices = linha_geom.asMultiPolyline()[0]  # Se a linha for do tipo poly
        else:
            linha_vertices = linha_geom.asPolyline()

        # Criar a geometria da linha base
        linha_base = QgsGeometry.fromPolylineXY([QgsPointXY(p) for p in linha_vertices])

        # Encontrar os pontos extremos de cada lado da linha base (sempre terá 1 ou 2 pontos)
        ponto_extremo_dir = None
        ponto_extremo_esq = None
        dist_max_dir = 0 # float('-inf')
        dist_max_esq = 0 # float('-inf')

        # Iterar sobre os vértices do polígono
        ponto1 = QgsPointXY(linha_vertices[0])
        ponto2 = QgsPointXY(linha_vertices[1])

        for ponto_atual in vertices:
            # Calcular o produto vetorial para determinar se o ponto está à direita ou à esquerda
            produto_vetorial = (ponto2.x() - ponto1.x()) * (ponto_atual.y() - ponto1.y()) - (ponto2.y() - ponto1.y()) * (ponto_atual.x() - ponto1.x())

            # Calcular a distância perpendicular do ponto à linha base
            numerador = abs((ponto2.y() - ponto1.y()) * ponto_atual.x() - (ponto2.x() - ponto1.x()) * ponto_atual.y() + ponto2.x() * ponto1.y() - ponto2.y() * ponto1.x())
            denominador = math.sqrt((ponto2.y() - ponto1.y())**2 + (ponto2.x() - ponto1.x())**2)
            dist_perpendicular = numerador / denominador if denominador != 0 else 0

            # Atualizar o ponto extremo à direita (produto vetorial positivo)
            if produto_vetorial > 0 and dist_perpendicular > dist_max_dir:
                dist_max_dir = dist_perpendicular
                ponto_extremo_dir = ponto_atual

            # Atualizar o ponto extremo à esquerda (produto vetorial negativo)
            elif produto_vetorial < 0 and dist_perpendicular > dist_max_esq:
                dist_max_esq = dist_perpendicular
                ponto_extremo_esq = ponto_atual

        # Adicionar os pontos extremos encontrados à lista
        pontos_extremos = []
        if ponto_extremo_dir:
            pontos_extremos.append(ponto_extremo_dir)
        if ponto_extremo_esq:
            pontos_extremos.append(ponto_extremo_esq)

        # Criar camada temporária para o(s) ponto(s) oposto(s); a maioria das vezes será um ponto só
        pontosExtremos_layer = QgsVectorLayer('Point?crs=' + crs.authid(), 'Pontos Extremos', 'memory')
        pontos_provider = pontosExtremos_layer.dataProvider()
        pontos_provider.addAttributes([QgsField('id', QVariant.Int)])
        pontosExtremos_layer.updateFields()

        # Adicionar os pontos extremos à camada temporária
        for feature_id, ponto in enumerate(pontos_extremos, start=1):
            if ponto:
                ponto_feature = QgsFeature()
                ponto_feature.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(ponto)))
                ponto_feature.setAttributes([feature_id])  # ID do ponto
                pontos_provider.addFeature(ponto_feature)

        if teste == True:
            QgsProject.instance().addMapLayer(pontosExtremos_layer)

        # Criar uma linha estendida sobre a linha base

         # ponto inicial e final da linha base
        p1 = linha_vertices[0]
        p2 = linha_vertices[1]

        dx = p2.x() - p1.x()
        dy = p2.y() - p1.y()
        angulo = math.atan2(dy, dx)

        extensao_x = (dist_max_esq + dist_max_dir) * math.cos(angulo) * 3 # multiplicando por 3 para os casos de escolher um lado mais curto
        extensao_y = (dist_max_esq + dist_max_dir) * math.sin(angulo) * 3

        p1_estendido = QgsPointXY(p1.x() - extensao_x ,p1.y() - extensao_y)
        p2_estendido = QgsPointXY(p2.x() + extensao_x ,p2.y() + extensao_y)
        linha_estendida = QgsGeometry.fromPolylineXY([QgsPointXY(p1_estendido), QgsPointXY(p2_estendido)])

        # Criar camada temporária para a linha estendida
        linhaEstendida_layer = QgsVectorLayer('LineString?crs=' + crs.authid(), 'Linha Estendida', 'memory')
        linha_provider = linhaEstendida_layer.dataProvider()
        linha_provider.addAttributes([QgsField('id', QVariant.Int)])
        linhaEstendida_layer.updateFields()

        linha_feature = QgsFeature()
        linha_feature.setGeometry(linha_estendida)
        linha_feature.setAttributes([1])  # ID da linha estendida
        linha_provider.addFeature(linha_feature)

        if teste == True:
            QgsProject.instance().addMapLayer(linhaEstendida_layer)

        # Criar linhas Paralelas à linha base até o(s) ponto(s) extremo(s)
        paralelas_layer = QgsVectorLayer('LineString?crs=' + crs.authid(), 'Linhas Paralelas', 'memory')
        paralelas_provider = paralelas_layer.dataProvider()
        paralelas_provider.addAttributes([QgsField('id', QVariant.Int)])
        paralelas_layer.updateFields()

        # Incluir a linha como a primeira linha paralela
        primeira_linha_feature = self.parameterAsVectorLayer(parameters, 'primeira_linha', context).getFeature(0)
        primeira_linha = primeira_linha_feature.geometry()
        linha_id = 1
        paralela_feature = QgsFeature()
        paralela_feature.setGeometry(primeira_linha)
        paralela_feature.setAttributes([linha_id])
        paralelas_provider.addFeature(paralela_feature)

        pontos_extremos = []
        if ponto_extremo_dir:  # Se existe o ponto extremo à direita
            dist = linha_estendida.distance(QgsGeometry.fromPointXY(QgsPointXY(ponto_extremo_dir))) if ponto_extremo_dir else 0
            pontos_extremos.append((dist, 1))  # Distância e sentido para o ponto direito

        if ponto_extremo_esq:  # Se existe o ponto extremo à esquerda
            dist = linha_estendida.distance(QgsGeometry.fromPointXY(QgsPointXY(ponto_extremo_esq))) if ponto_extremo_esq else 0
            pontos_extremos.append((dist, -1))  # Distância e sentido para o ponto esquerdo

        # Criar as paralelas em um sentido de cada vez
        for dist, sentido in pontos_extremos:
            deslocamento = deltaLat * sentido  # Usando a direção positiva ou negativa

            while abs(deslocamento) <= dist:  # Criar linhas paralelas até o ponto extremo
                linha_id += 1

                # Deslocamento da linha base para criar a paralela
                parameters = {
                    'INPUT': linhaEstendida_layer,  # Linha base
                    'DISTANCE': deslocamento,
                    'OUTPUT': 'memory:'
                }

                result = processing.run("native:offsetline", parameters)
                linha_paralela_layer = result['OUTPUT']

                # Obter a geometria da linha paralela
                feature = next(linha_paralela_layer.getFeatures(), None)
                linha_geom = feature.geometry() if feature else None

                if linha_geom:
                    # Interseção da linha paralela com o polígono
                    intersecao_geom = linha_geom.intersection(poligono_geom)

                    # Adicionar a paralela à camada
                    paralela_feature = QgsFeature()
                    paralela_feature.setGeometry(intersecao_geom)
                    paralela_feature.setAttributes([linha_id])
                    paralelas_provider.addFeature(paralela_feature)
                    paralelas_layer.updateExtents()

                    # Atualizar a linha base para a próxima paralela
                    linha_estendida = linha_paralela_layer

                    deslocamento += deltaLat * sentido  # Atualizar o deslocamento

        if teste == True:
            QgsProject.instance().addMapLayer(paralelas_layer)

        # Criar a camada com a união das linhas paralelas
        linhas_layer = QgsVectorLayer('LineString?crs=' + crs.authid(), 'Linhas', 'memory')
        linhas_provider = linhas_layer.dataProvider()
        linhas_provider.addAttributes([QgsField('id', QVariant.Int)])
        linhas_provider.addAttributes([QgsField('altitude', QVariant.Double)])
        linhas_layer.updateFields()

        paralelas_features = list(paralelas_layer.getFeatures())
        linha_id = 1

        for i in range(len(paralelas_features)):
            # Adicionar a linha paralela à camada
            linha_paralela = paralelas_features[i]
            linha_paralela.setAttributes([linha_id])
            linhas_provider.addFeature(linha_paralela)
            linha_id += 1

            # Criar a linha de costura
            if i < len(paralelas_features) - 1:
                geom_atual = paralelas_features[i].geometry()
                geom_seguinte = paralelas_features[i + 1].geometry()

                # Obter os extremos das linhas (direita ou esquerda alternando)
                extremos_atual = list(geom_atual.vertices())
                extremos_seguinte = list(geom_seguinte.vertices())

                if i % 2 == 0:  # Conecta pelo lado direito
                    ponto_inicio = QgsPointXY(extremos_atual[-1])  # Extremo final da linha atual
                    ponto_fim = QgsPointXY(extremos_seguinte[-1])  # Extremo final da próxima linha
                else:  # Conecta pelo lado esquerdo
                    ponto_inicio = QgsPointXY(extremos_atual[0])  # Extremo inicial da linha atual
                    ponto_fim = QgsPointXY(extremos_seguinte[0])  # Extremo inicial da próxima linha

                # Criar a geometria da linha de costura
                conexao_geom = QgsGeometry.fromPolylineXY([ponto_inicio, ponto_fim])
                conexao_feature = QgsFeature()
                conexao_feature.setGeometry(conexao_geom)
                conexao_feature.setAttributes([linha_id])
                linhas_provider.addFeature(conexao_feature)

                linha_id += 1

        # Atualizar extensão da camada de resultado
        linhas_layer.updateExtents()

        # Verificar se as linhas estão contínuas
        linhas = sorted(linhas_layer.getFeatures(), key=lambda f: f['id'])

        for i in range(len(linhas) - 1):
            geom_atual = linhas[i].geometry()
            geom_seguinte = linhas[i + 1].geometry()

            # Obter os extremos das linhas (direita ou esquerda alternando)
            extremos_atual = list(geom_atual.vertices())
            extremos_seguinte = list(geom_seguinte.vertices())

            ponto_final_atual = QgsPointXY(extremos_atual[-1].x(), extremos_atual[-1].y())  # Extremo final da linha atual
            ponto_inicial_seguinte = QgsPointXY(extremos_seguinte[0].x(), extremos_seguinte[0].y())  # Extremo inicial da próxima linha

            if ponto_final_atual != ponto_inicial_seguinte: # se for igual continua para a próxima linha
                extremos_seguinte = [QgsPointXY(p.x(), p.y()) for p in reversed(extremos_seguinte)] # Invertemos os vértices da linha seguinte
                geom_seguinte = QgsGeometry.fromPolylineXY(extremos_seguinte)

                # Atualizar imediatamente a geometria da linha na camada
                linhas_layer.dataProvider().changeGeometryValues({linhas[i + 1].id(): geom_seguinte})

                # Atualizar a linha seguinte na lista local para manter consistência no loop
                linhas[i + 1].setGeometry(geom_seguinte)

        # Atualizar a extensão da camada
        linhas_layer.updateExtents()

        if teste == True:
            QgsProject.instance().addMapLayer(linhas_layer)

        # Criação de uma linha única para Linha de Voo
        linha_voo_layer = QgsVectorLayer('LineString?crs=' + crs.authid(), 'Linha de Voo', 'memory')
        linha_voo_provider = linha_voo_layer.dataProvider()
        linha_voo_provider.addAttributes([QgsField('id', QVariant.Int)])
        linha_voo_provider.addAttributes([QgsField('alturavoo', QVariant.Double)])
        linha_voo_layer.updateFields()

        # Obter e ordenar as feições pela ordem dos IDs para garantir
        linhas = sorted(linhas_layer.getFeatures(), key=lambda f: f['id'])

        # Iniciar a lista de coordenadas para a linha única
        linha_unica_coords = []

        # Adicionar coordenadas de todas as linhas em ordem
        for f in linhas:
            geom = f.geometry()
            if geom.isMultipart():
                partes = geom.asMultiPolyline()
                for parte in partes:
                    linha_unica_coords.extend(parte)  # Adicionar todas as partes
            else:
                linha_unica_coords.extend(geom.asPolyline())  # Adicionar a linha simples

        # Criar a geometria combinada a partir das coordenadas coletadas
        linha_unica_geom = QgsGeometry.fromPolylineXY(linha_unica_coords)

        # Criar a feature para a linha única
        linha_unica_feature = QgsFeature()
        linha_unica_feature.setGeometry(linha_unica_geom)
        linha_unica_feature.setAttributes([1])  # Atributo ID = 1

        # Adicionar a feature à camada de linha de voo
        linha_voo_provider.addFeature(linha_unica_feature)

        # Atualizar extensão da camada de resultado
        linha_voo_layer.updateExtents()

        # o final da Linha de Voo será feito no final da criação dos Pontos de Fotos,
        # pois precisamos da altura média dos Pontos para atribuir à Linha de Voo

        # ===== Final Parcial Linha de Voo (precisa ainda colocar altitude média) =======
        # ===============================================================================


        # ===============================================================================
        # =====Criar a camada Pontos de Fotos============================================

        # Criar uma camada Ponto com os deltaFront sobre a linha
        pontos_fotos = QgsVectorLayer('Point?crs=' + crs.authid(), 'Pontos Fotos', 'memory')
        pontos_provider = pontos_fotos.dataProvider()

        # Definir campos
        campos = QgsFields()
        campos.append(QgsField("id", QVariant.Int))
        campos.append(QgsField("latitude", QVariant.Double))
        campos.append(QgsField("longitude", QVariant.Double))
        campos.append(QgsField("altitude", QVariant.Double))
        campos.append(QgsField("alturavoo", QVariant.Double))
        pontos_provider.addAttributes(campos)
        pontos_fotos.updateFields()

        linha_voo = next(linha_voo_layer.getFeatures())  # Pegando a única linha
        geom_linha = linha_voo.geometry() # Obter a geometria da linha

        # Obter a geometria do polígono a partir da camada
        poligono_feature = next(area_layer.getFeatures())  # Assumindo que a camada contém apenas um polígono
        poligono_geom = poligono_feature.geometry()  # Geometria do polígono

        # Criar um buffer com tolerância de 3 metros
        tolerancia = 3  # Margem de 3 metros
        poligono_com_tolerancia = poligono_geom.buffer(tolerancia, 5)  # Buffer com 5 segmentos por quadrante

        # Obter o ponto inicial da linha
        ponto_inicial = QgsPointXY(geom_linha.vertexAt(0))

        # Gerar pontos
        pontoID = 1
        distVoo = geom_linha.length()
        distAtual = 0

        # Primeiro Ponto no início da primeira linha da Linha de Voo
        ponto_feature = QgsFeature()
        ponto_feature.setFields(campos)
        ponto_feature.setAttribute("id", pontoID)
        ponto_feature.setAttribute("latitude", ponto_inicial.y())
        ponto_feature.setAttribute("longitude", ponto_inicial.x())
        ponto_feature.setGeometry(QgsGeometry.fromPointXY(ponto_inicial))
        pontos_provider.addFeature(ponto_feature)

        pontoID += 1

        while True:
            distAtual += deltaFront

            if distAtual > (distVoo):  # Evitar extrapolação além do comprimento da linha
                feedback.pushInfo(f"Dist. Atual: {round(distAtual,2)}, Dist. Voo: {round(distVoo,2)}")
                break

            ponto = geom_linha.interpolate(distAtual).asPoint()
            ponto_geom = QgsGeometry.fromPointXY(QgsPointXY(ponto))

            # Adicionar ponto somente se estiver dentro do polígono
            if poligono_com_tolerancia.contains(ponto_geom):
                ponto_feature = QgsFeature()
                ponto_feature.setFields(campos)
                ponto_feature.setAttribute("id", pontoID)
                ponto_feature.setAttribute("latitude", ponto.y())
                ponto_feature.setAttribute("longitude", ponto.x())
                ponto_feature.setGeometry(ponto_geom)
                pontos_provider.addFeature(ponto_feature)

                pontoID += 1

        # Atualizar a camada
        pontos_fotos.updateExtents()

        # Obter a altitude dos pontos das Fotos
        prov = pontos_fotos.dataProvider()
        pontos_fotos.startEditing()

        # definir o valor de Z
        for f in pontos_fotos.getFeatures():
            point = f.geometry().asPoint()

            # Transformar coordenada para CRS do raster
            point_wgs = transformador.transform(QgsPointXY(point.x(), point.y()))

            # Obter o valor de Z do MDE
            value, result = camadaMDE.dataProvider().sample(point_wgs, 1)  # Resolução = 1
            if result:
                f['altitude'] = value
                f['alturavoo'] = value + H  # altura de Voo
                pontos_fotos.updateFeature(f)

        pontos_fotos.commitChanges()

        # Point para PointZ
        pontos_fotos = set_Z_value(pontos_fotos, z_field="alturavoo")

        # Reprojetar camada Pontos Fotos de UTM para WGS84 (4326)
        pontos_reproj = reprojeta_camada_WGS84(pontos_fotos, crs_wgs, transformador)

        # Reprojetar a camada para WGS 84
        pontos_reproj = set_Z_value(pontos_reproj, z_field="alturavoo")

        # Simbologia
        simbologiaPontos(pontos_reproj)

        # ===== PONTOS FOTOS ==========================
        QgsProject.instance().addMapLayer(pontos_reproj)

        # ===== Final Pontos Fotos ============================================
        # =====================================================================

        # ===== Linha de Voo com Altitudes para o Google Earth Pro ============
        # =====================================================================

        # Determinar as altitudes baseado no Pontos

        # Criar a lista de vértices (com valores de Z)
        lista_vertices = []
        for feature in pontos_fotos.getFeatures():
            geom = feature.geometry()
            ponto = geom.asPoint()
            z = feature['alturavoo']
            ponto_z = QgsPoint(ponto.x(), ponto.y(), z)  # Criar ponto com Z (altitude)
            lista_vertices.append(ponto_z)

        # Calcular a média das altitudes como exemplo
        media_altitude = sum([p.z() for p in lista_vertices]) / len(lista_vertices)

        # Criar a geometria da linha
        linha_geom = QgsGeometry.fromPolyline(lista_vertices)

        # Criar a feature (linha) com a geometria e atributos
        feature_linha = QgsFeature()
        feature_linha.setGeometry(linha_geom)

        linha_voo_layer.startEditing()

        linha_voo_provider.changeAttributeValues({feature_id: {1: media_altitude}})

        linha_voo_layer.triggerRepaint()  # Redesenhar a camada para refletir as alterações
        linha_voo_layer.updateFields()    # Atualizar os campos da camada
        linha_voo_layer.updateExtents()   # Atualizar a extensão da camada
        linha_voo_layer.commitChanges()

        # Reprojetar linha_voo_layer para WGS84 (4326)
        linha_voo_reproj = reprojeta_camada_WGS84(linha_voo_layer, crs_wgs, transformador)

        # LineString para LineStringZ
        linha_voo_reproj = set_Z_value(linha_voo_reproj, z_field="alturavoo")

        # Configurar simbologia de seta
        simbologiaLinhaVoo("H", linha_voo_reproj)

        # ===== LINHA DE VOO ==============================
        QgsProject.instance().addMapLayer(linha_voo_reproj)

        # ===== Final Linha de Voo ============================================
        # =====================================================================

        feedback.pushInfo("")
        feedback.pushInfo("Flight Line and Photo Spots completed successfully!")

        # =========Exportar para o Google  E a r t h   P r o  (kml)================================================

        # Verifica se o caminho é válido, não é 'TEMPORARY OUTPUT' e é um diretório
        if caminho_kml and caminho_kml != 'TEMPORARY OUTPUT' and os.path.isdir(caminho_kml):
            arquivo_kml = os.path.join(caminho_kml, "Pontos Fotos.kml")
            gerar_KML(pontos_reproj, arquivo_kml, crs_wgs, feedback)

            arquivo_kml = os.path.join(caminho_kml, "Linha de Voo.kml")
            gerar_KML(linha_voo_reproj, arquivo_kml, crs_wgs, feedback)
        else:
            feedback.pushInfo("KML path not specified. Export step skipped.")

        # =============L I T C H I==========================================================

        if arquivo_csv and arquivo_csv.endswith('.csv'): # Verificar se o caminho CSV está preenchido
            gerar_CSV("H", pontos_reproj, arquivo_csv, velocidade, tempo, deltaFront, 360, H)
        else:
            feedback.pushInfo("CSV path not specified. Export step skipped.")

        # ============= Mensagem de Encerramento =====================================================
        feedback.pushInfo("")
        feedback.pushInfo("Horizontal Flight Plan successfully executed.")

        return {}

    def name(self):
        return 'FollowingTerrain'.lower()

    def displayName(self):
        return self.tr('Following terrain')

    def group(self):
        return 'Horizontal Flight'

    def groupId(self):
        return 'horizontal'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return PlanoVoo_H()

    def tags(self):
        return self.tr('Flight Plan,Measure,Topography,Plano voo,Plano de voo,voo,drone').split(',')

    def icon(self):
        return QIcon(os.path.join(os.path.dirname(os.path.dirname(__file__)), 'images/Horizontal.png'))

    texto = """Este algoritmo calcula a sobreposição lateral e frontal para um Voo de Drone,
            fornecendo uma camada da 'Linha do Voo' e uma camada dos 'Pontos' para Fotos.
            Gera ainda: a planilha CSV para importar no Litchi e o arquivo KML para Google Earth.
            Se você usa um aplicativo para Voo que não seja o Litchi, pode usar os pontos gerados no QGIS ou os arquivos KML.

            Dados necessários:
            1. Área a ser levantada (um pouco maior)
            2. Uma linha de Início do Voo (criar próximo ao lado que ser quer iniciar o Voo)
            3. Dados do Drone
            4. Altura do Voo (m)
            5. Velocidade do Voo (m/s)
            6. Tempo de espera para tirar a Foto (s)
            7. Chave API do Open Topography
            8. Caminho para gravar os KML
            9. Arquivo para gravar o CSV para o Litchi
            Artigo: https://geoone.com.br/plano-de-voo-para-drone-com-python/
            """

    figura2 = 'images/VooH2.jpg'

    def shortHelpString(self):
        corpo = '''<div align="center">
                      <img src="'''+ os.path.join(os.path.dirname(os.path.dirname(__file__)), self.figura2) +'''">
                      </div>
                      <div align="right">
                      <p align="right">
                      <b>Autores: Prof Cazaroli     -     Leandro França</b>
                      </p>GeoOne</div>
                    </div>'''
        return self.tr(self.texto) + corpo
