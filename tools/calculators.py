# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Flight Planner H - using data from the Drone's camera sensors
                                 A QGIS plugin
 Flight Planner H
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-07-04
        copyright            : (C) 2025 by Prof Cazaroli e Leandro França (Professor Ilton contributed to the project)
        email                : contato@geoone.com.br
***************************************************************************/
"""

__author__ = 'Prof Cazaroli and Leandro França (Professor Ilton contributed to the project)'
__date__ = '2025-07-04'
__copyright__ = '(C) 2025 by Prof Cazaroli and Leandro França (Professor Ilton contributed to the project)'
__revision__ = '$Format:%H$'

from PyQt5.QtWidgets import (
    QLineEdit, QLabel, QPushButton, QMessageBox, QVBoxLayout, QGroupBox, QFormLayout, QWidget
)
from PyQt5.QtCore import Qt
import os
import math
from qgis.core import (QgsProject, QgsFeature, QgsVectorLayer)
from functools import lru_cache
from .global_settings import get_drone_feature, DRONE_DATA_PATH, calculate_and_add_drone, clear_drone_cache

def _get_numeric_value(text_input, name, target_type=float, allow_empty=False):
    """Safely converts QLineEdit text to a numeric type, handling empty strings and errors."""
    text = text_input.text().strip().replace(',', '.')
    if not text:
        if allow_empty:
            return None
        else:
            raise ValueError(f"The field '{name}' cannot be empty.")
    try:
        return target_type(text)
    except ValueError:
        raise ValueError(f"Invalid value for '{name}': '{text}'. Please enter a valid number.")

def _validate_drone_data_fields(data, fields):
    """Ensures required drone data fields are present and not None."""
    for field in fields:
        if data.get(field) is None or (isinstance(data.get(field), str) and data.get(field).strip() == ''):
            raise ValueError(f"Incomplete drone data: Field '{field}' is missing or empty for the selected drone.")
    return data



# GSD CALCULATOR BY PIXEL
def calculate_gsd_by_pixel(drone_model: str, altitude_m: float) -> float:
    data = get_drone_feature(drone_model)
    _validate_drone_data_fields(data, ["pixel_size", "focal_length"])
    pixel_size_um = float(data["pixel_size"])
    focal_length_mm = float(data["focal_length"])

    if focal_length_mm == 0:
        raise ValueError("Focal length cannot be zero.")

    gsd_m = (pixel_size_um / 1000 / focal_length_mm) * altitude_m
    return gsd_m * 100  # cm/pixel

# GSD CALCULATOR BY SENSOR DIMENSION
def calculate_gsd_by_sensor_dimension(drone_model: str, altitude_m: float) -> float:
    data = get_drone_feature(drone_model)
    _validate_drone_data_fields(data, ["sensor_width", "image_width", "focal_length"])
    sensor_width_mm = float(data["sensor_width"])
    image_width_px = float(data["image_width"])
    focal_length_mm = float(data["focal_length"])

    if image_width_px == 0:
        raise ValueError("Image width in pixels cannot be zero.")
    if focal_length_mm == 0:
        raise ValueError("Focal length cannot be zero.")

    pixel_size_mm = sensor_width_mm / image_width_px
    gsd_m = (pixel_size_mm / focal_length_mm) * altitude_m
    return gsd_m * 100  # cm/pixel

# SPACING CALCULATOR
def calculate_spacing(drone_model: str, flight_type: str, camera_orientation: str,
                         flight_height: QLineEdit, lateral_percentage: QLineEdit, frontal_percentage: QLineEdit, allow_empty: bool = False) -> dict:
    data = get_drone_feature(drone_model)
    _validate_drone_data_fields(data, ["sensor_width", "sensor_height", "focal_length"])

    sw = float(data["sensor_width"])
    sh = float(data["sensor_height"])
    f = float(data["focal_length"])

    H = _get_numeric_value(flight_height, "Flight height", allow_empty=allow_empty)
    perc_lat = _get_numeric_value(lateral_percentage, "Lateral percentage", target_type=float, allow_empty=allow_empty)
    perc_front = _get_numeric_value(frontal_percentage, "Frontal percentage", target_type=float, allow_empty=allow_empty)

    if any(val is None for val in [H, perc_lat, perc_front]):
        return None

    perc_lat /= 100
    perc_front /= 100

    if f == 0:
        raise ValueError("Focal length cannot be zero.")
    if H <= 0:
        raise ValueError("Flight height must be greater than zero.")

    if camera_orientation == "Retrato": # Assuming "Retrato" is Portrait, so swap
        sw, sh = sh, sw

    gsw = (sw * H) / f
    gsh = (sh * H) / f

    lateral_spacing = gsw * (1 - perc_lat)
    frontal_spacing = gsh * (1 - perc_front)

    if flight_type == "Voo Horizontal (Nadir)": # Assuming "Voo Horizontal (Nadir)" is Horizontal Flight (Nadir)
        return {
            "lateral_spacing": f"Lateral Spacing: {lateral_spacing:.2f} m",
            "frontal_spacing": f"Frontal Spacing: {frontal_spacing:.2f} m"
        }
    else: # Assuming "Voo Vertical/Fachada" is Vertical/Facade Flight
        return {
            "lateral_spacing": f"Horizontal Spacing (photos): {lateral_spacing:.2f} m",
            "frontal_spacing": f"Vertical Spacing (lines): {frontal_spacing:.2f} m"
        }

# OVERLAP CALCULATOR
def calculate_overlap(drone_model: str, flight_type: str, camera_orientation: str,
                          flight_height: QLineEdit, line_spacing: QLineEdit, photo_spacing: QLineEdit, allow_empty: bool = False) -> dict:
    data = get_drone_feature(drone_model)
    _validate_drone_data_fields(data, ["sensor_width", "sensor_height", "focal_length"])

    sw = float(data["sensor_width"])
    sh = float(data["sensor_height"])
    f = float(data["focal_length"])

    H = _get_numeric_value(flight_height, "Flight height", allow_empty=allow_empty)
    spacing_lines = _get_numeric_value(line_spacing, "Line spacing", allow_empty=allow_empty)
    spacing_photos = _get_numeric_value(photo_spacing, "Photo spacing", allow_empty=allow_empty)

    if any(val is None for val in [H, spacing_lines, spacing_photos]):
        return None

    if f == 0:
        raise ValueError("Focal length cannot be zero.")
    if H <= 0:
        raise ValueError("Flight height must be greater than zero.")

    if camera_orientation == "Retrato": # Assuming "Retrato" is Portrait, so swap
        sw, sh = sh, sw

    gsw = (sw * H) / f
    gsh = (sh * H) / f

    if gsw == 0:
        raise ValueError("Sensor width GSD is zero. Check drone data or flight height.")
    if gsh == 0:
        raise ValueError("Sensor height GSD is zero. Check drone data or flight height.")

    overlap_lat = (1 - spacing_photos / gsw) * 100
    overlap_front = (1 - spacing_lines / gsh) * 100

    overlap_lat = max(0, min(overlap_lat, 100))
    overlap_front = max(0, min(overlap_front, 100))

    if flight_type == "Voo Horizontal (Nadir)": # Assuming "Voo Horizontal (Nadir)" is Horizontal Flight (Nadir)
        return {
            "lateral_overlap": f"Lateral Overlap: {overlap_lat:.2f}%",
            "frontal_overlap": f"Frontal Overlap: {overlap_front:.2f}%"
        }
    else: # Assuming "Voo Vertical/Fachada" is Vertical/Facade Flight
        return {
            "lateral_overlap": f"Horizontal Overlap (photos): {overlap_lat:.2f}%",
            "frontal_overlap": f"Vertical Overlap (lines): {overlap_front:.2f}%"
        }

# CALCULATOR WITH VARIOUS PARAMETERS
def calculate_flight_parameters(drone_model: str, flight_height: QLineEdit, shutter_speed: QLineEdit,
                            interval: QLineEdit, overlap: QLineEdit, allow_empty: bool = False) -> dict:
    data = get_drone_feature(drone_model)
    _validate_drone_data_fields(data, ["sensor_width", "image_width", "image_height", "focal_length"])

    sw = float(data["sensor_width"])
    iw = float(data["image_width"])
    ih = float(data["image_height"])
    f = float(data["focal_length"])

    H = _get_numeric_value(flight_height, "Flight height", allow_empty=allow_empty)
    shutter_inv = _get_numeric_value(shutter_speed, "Shutter speed (1/x s, enter x)", allow_empty=allow_empty)
    interval_val = _get_numeric_value(interval, "Interval between photos", allow_empty=allow_empty)
    overlap_val = _get_numeric_value(overlap, "Desired flight overlap", allow_empty=allow_empty)

    if any(val is None for val in [H, shutter_inv, interval_val, overlap_val]):
        return None

    overlap_val /= 100

    if f == 0:
        raise ValueError("Focal length cannot be zero.")
    if H <= 0:
        raise ValueError("Flight height must be greater than zero.")
    if iw == 0:
        raise ValueError("Image width in pixels cannot be zero.")
    if ih == 0:
        raise ValueError("Image height in pixels cannot be zero.")

    px_size_mm = sw / iw
    gsd_m = (px_size_mm / f) * H
    gsd_cm = gsd_m * 100

    shutter_time = 1 / shutter_inv if shutter_inv != 0 else float("inf")
    max_blur_speed = gsd_m / shutter_time

    footprint_w = gsd_m * iw
    footprint_h = gsd_m * ih

    util_dist = footprint_h * (1 - overlap_val)
    overlap_speed = util_dist / interval_val if interval_val > 0 else float("inf")

    area_m = 120
    
    # Ensure no division by zero for footprint dimensions
    if (footprint_w * (1 - overlap_val)) == 0 or (footprint_h * (1 - overlap_val)) == 0:
        raise ValueError("Footprint calculation resulted in zero. Check input data.")

    photos_w = math.ceil(area_m / (footprint_w * (1 - overlap_val)))
    photos_h = math.ceil(area_m / (footprint_h * (1 - overlap_val)))
    total_photos = photos_w * photos_h

    total_time = total_photos * interval_val + 120
    min_, sec = divmod(int(total_time), 60)

    return {
        "gsd": f"GSD: {gsd_cm:.2f} cm/pixel",
        "max_speed_blur": f"Max speed (blur): {max_blur_speed:.2f} m/s",
        "footprint": f"Ground footprint: {footprint_w:.1f}m x {footprint_h:.1f}m",
        "overlap_speed": f"Speed for Overlap: {overlap_speed:.2f} m/s",
        "photo_count": f"Photos (120x120m): {total_photos}",
        "flight_time": f"Duration (120x120m): {min_} min {sec} s"
    }
