# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Calculator GSD
 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-07-04
        copyright            : (C) 2025 by Prof Cazaroli and Leandro França and Prof Ilton
        email                : contato@geoone.com.br
***************************************************************************/
"""

__author__ = 'Prof Cazaroli and Leandro França and Prof Ilton'
__date__ = '2025-07-04'
__copyright__ = '(C) 2025 by Prof Cazaroli and Leandro França and Prof Ilton'
__revision__ = '$Format:%H$'

from PyQt5.QtWidgets import (
    QLineEdit, QLabel, QPushButton, QMessageBox, QVBoxLayout, QGroupBox, QFormLayout, QWidget
)
from PyQt5.QtCore import Qt
import os
import math
from qgis.core import (QgsProject, QgsFeature, QgsVectorLayer)
from functools import lru_cache
from .global_settings import get_drone_feature, DRONE_DATA_PATH, calculate_and_add_drone, clear_drone_cache

def _get_numeric_value(text_input, name, target_type=float, allow_empty=False):
    """Safely converts QLineEdit text to a numeric type, handling empty strings and errors."""
    text = text_input.text().strip().replace(',', '.')
    if not text:
        if allow_empty:
            return None
        else:
            raise ValueError(f"The field '{name}' cannot be empty.")
    try:
        return target_type(text)
    except ValueError:
        raise ValueError(f"Invalid value for '{name}': '{text}'. Please enter a valid number.")

def _validate_drone_data_fields(data, fields):
    """Ensures required drone data fields are present and not None."""
    for field in fields:
        if data.get(field) is None or (isinstance(data.get(field), str) and data.get(field).strip() == ''):
            raise ValueError(f"Incomplete drone data: Field '{field}' is missing or empty for the selected drone.")
    return data

# GSD CALCULATOR BY SENSOR DIMENSION
def calculate_gsd_by_sensor_dimension(drone_model: str, altitude_m: float) -> float:
    data = get_drone_feature(drone_model)
    _validate_drone_data_fields(data, ["sensor_width", "image_width", "focal_length"])
    sensor_width_mm = float(data["sensor_width"])
    image_width_px = float(data["image_width"])
    focal_length_mm = float(data["focal_length"])

    if image_width_px == 0:
        raise ValueError("Image width in pixels cannot be zero.")
    if focal_length_mm == 0:
        raise ValueError("Focal length cannot be zero.")

    pixel_size_mm = sensor_width_mm / image_width_px
    gsd_m = (pixel_size_mm / focal_length_mm) * altitude_m
    return gsd_m * 100  # cm/pixel

# SPACING CALCULATOR BY OVERLAP
def calculate_spacing(drone_model: str, flight_type: str, camera_orientation: str,
                         flight_height: QLineEdit, lateral_percentage: QLineEdit, frontal_percentage: QLineEdit, allow_empty: bool = False) -> dict:
    data = get_drone_feature(drone_model)
    _validate_drone_data_fields(data, ["sensor_width", "sensor_height", "focal_length"])

    sw = float(data["sensor_width"])
    sh = float(data["sensor_height"])
    f = float(data["focal_length"])

    H = _get_numeric_value(flight_height, "Flight height", allow_empty=allow_empty)
    perc_lat = _get_numeric_value(lateral_percentage, "Lateral percentage", target_type=float, allow_empty=allow_empty)
    perc_front = _get_numeric_value(frontal_percentage, "Frontal percentage", target_type=float, allow_empty=allow_empty)

    if any(val is None for val in [H, perc_lat, perc_front]):
        return None

    perc_lat /= 100
    perc_front /= 100

    if f == 0:
        raise ValueError("Focal length cannot be zero.")
    if H <= 0:
        raise ValueError("Flight height must be greater than zero.")

    if camera_orientation == "Retrato": # Assuming "Retrato" is Portrait, so swap
        sw, sh = sh, sw

    gsw = (sw * H) / f
    gsh = (sh * H) / f

    lateral_spacing = gsw * (1 - perc_lat)
    frontal_spacing = gsh * (1 - perc_front)

    if flight_type == "Voo Horizontal (Nadir)": # Assuming "Voo Horizontal (Nadir)" is Horizontal Flight (Nadir)
        return {
            "lateral_spacing": f"Lateral Spacing: {lateral_spacing:.2f} m",
            "frontal_spacing": f"Frontal Spacing: {frontal_spacing:.2f} m"
        }
    else: # Assuming "Voo Vertical/Fachada" is Vertical/Facade Flight
        return {
            "lateral_spacing": f"Horizontal Spacing (photos): {lateral_spacing:.2f} m",
            "frontal_spacing": f"Vertical Spacing (lines): {frontal_spacing:.2f} m"
        }

# OVERLAP CALCULATOR BY SPACING
def calculate_overlap(drone_model: str, flight_type: str, camera_orientation: str,
                          flight_height: QLineEdit, line_spacing: QLineEdit, photo_spacing: QLineEdit, allow_empty: bool = False) -> dict:
    data = get_drone_feature(drone_model)
    _validate_drone_data_fields(data, ["sensor_width", "sensor_height", "focal_length"])

    sw = float(data["sensor_width"])
    sh = float(data["sensor_height"])
    f = float(data["focal_length"])

    H = _get_numeric_value(flight_height, "Flight height", allow_empty=allow_empty)
    spacing_lines = _get_numeric_value(line_spacing, "Line spacing", allow_empty=allow_empty)
    spacing_photos = _get_numeric_value(photo_spacing, "Photo spacing", allow_empty=allow_empty)

    if any(val is None for val in [H, spacing_lines, spacing_photos]):
        return None

    if f == 0:
        raise ValueError("Focal length cannot be zero.")
    if H <= 0:
        raise ValueError("Flight height must be greater than zero.")

    if camera_orientation == "Retrato": # Assuming "Retrato" is Portrait, so swap
        sw, sh = sh, sw

    gsw = (sw * H) / f
    gsh = (sh * H) / f

    if gsw == 0:
        raise ValueError("Sensor width GSD is zero. Check drone data or flight height.")
    if gsh == 0:
        raise ValueError("Sensor height GSD is zero. Check drone data or flight height.")

    overlap_lat = (1 - spacing_photos / gsw) * 100
    overlap_front = (1 - spacing_lines / gsh) * 100

    overlap_lat = max(0, min(overlap_lat, 100))
    overlap_front = max(0, min(overlap_front, 100))

    if flight_type == "Voo Horizontal (Nadir)": # Assuming "Voo Horizontal (Nadir)" is Horizontal Flight (Nadir)
        return {
            "lateral_overlap": f"Lateral Overlap: {overlap_lat:.2f}%",
            "frontal_overlap": f"Frontal Overlap: {overlap_front:.2f}%"
        }
    else: # Assuming "Voo Vertical/Fachada" is Vertical/Facade Flight
        return {
            "lateral_overlap": f"Horizontal Overlap (photos): {overlap_lat:.2f}%",
            "frontal_overlap": f"Vertical Overlap (lines): {overlap_front:.2f}%"
        }
