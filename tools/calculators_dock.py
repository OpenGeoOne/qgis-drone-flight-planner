# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Flight Planner H - using data from the Drone's camera sensors
                                 A QGIS plugin
 Flight Planner H
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-07-04
        copyright            : (C) 2025 by Prof Cazaroli e Leandro França (Professor Ilton contributed to the project)
        email                : contato@geoone.com.br
***************************************************************************/
"""

__author__ = 'Prof Cazaroli and Leandro França (Professor Ilton contributed to the project)'
__date__ = '2025-07-04'
__copyright__ = '(C) 2025 by Prof Cazaroli and Leandro França (Professor Ilton contributed to the project)'
__revision__ = '$Format:%H$'

import os
import json
from qgis.PyQt.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QLineEdit, QFormLayout,
    QGroupBox, QDockWidget, QScrollArea, QComboBox,
    QPushButton, QMessageBox, QToolButton, QFrame
)
from qgis.PyQt.QtCore import Qt, QUrl, QSettings
from qgis.PyQt.QtGui import QDesktopServices

from .calculators import (
    calculate_gsd_by_pixel,
    calculate_gsd_by_sensor_dimension,
    calculate_spacing,
    calculate_overlap,
    calculate_flight_parameters,
    _get_numeric_value
)
from .global_settings import GlobalSettings, DRONE_DATA_PATH, get_drone_feature, create_add_sensor_section

class CalculatorsDock(QDockWidget):

    def __init__(self, parent=None):
        super(CalculatorsDock, self).__init__(parent)
        self.setWindowTitle(u'Calculators and Settings')
        self.setObjectName('CalculatorsDock')
        self.settings = QSettings()

        self.global_settings = GlobalSettings()
        self.init_gui()

    def init_gui(self):
        self.widget = QWidget()
        self.widget.setStyleSheet('''
            QLineEdit[readOnly="true"] {
                background-color: #f0f0f0; 
                color: #555;
                border: 1px solid #ccc;
            }
        ''')
        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.scroll.setWidget(self.widget)
        self.setWidget(self.scroll)

        self.layout = QVBoxLayout(self.widget)

        self.layout.addWidget(self.create_global_settings_section())

        calculators_group = QGroupBox("Flight Attribute Calculators")
        calculators_layout = QVBoxLayout()
        calculators_layout.addWidget(self.create_section_b())
        calculators_layout.addWidget(self.create_section_a())
        calculators_layout.addWidget(self.create_section_spacing())
        calculators_layout.addWidget(self.create_section_overlap())
        calculators_layout.addWidget(self.create_time_interval_section())
        
        # Add Help Button
        help_button = QPushButton("Help Calculator")
        help_button.clicked.connect(self.open_calculator_help)
        calculators_layout.addWidget(help_button)

        calculators_group.setLayout(calculators_layout)
        self.layout.addWidget(calculators_group)

        self.layout.addStretch()

        self.flight_type_combo.currentTextChanged.connect(self.update_calculation_logic_and_labels)
        self.camera_orientation_combo.currentTextChanged.connect(self.update_calculation_logic_and_labels)
        # Restore previously selected drone, if any
        last_selected_drone = self.settings.value("GeoFlightPlanner/selected_sensor", None)
        if last_selected_drone and last_selected_drone in [self.combo_drone.itemText(i) for i in range(self.combo_drone.count())]:
            self.combo_drone.setCurrentText(last_selected_drone)
        else:
            # Ensure the placeholder is selected if no valid previous selection
            self.combo_drone.setCurrentIndex(0)
        
        # Initial update of fields based on current selection (which might be the placeholder)
        self.update_drone_fields(self.combo_drone.currentText())

    def create_global_settings_section(self):
        group_box = QGroupBox("1. Global Flight Settings")
        form_layout = QFormLayout()

        self.combo_drone = QComboBox()
        placeholder_text = "Select a Sensor..."
        self.combo_drone.addItem(placeholder_text)

        try:
            with open(DRONE_DATA_PATH, 'r', encoding='utf-8') as f:
                drone_models = json.load(f)
            for modelo in sorted(drone_models.keys()):
                self.combo_drone.addItem(modelo)
        except (FileNotFoundError, json.JSONDecodeError) as e:
            QMessageBox.warning(self, "Error", f"Could not load drone data: {e}")

        self.combo_drone.currentTextChanged.connect(self.update_drone_fields)
        form_layout.addRow("1.1 Drone Model:", self.combo_drone)

        # Add "Add Sensor" section directly to QFormLayout
        add_sensor_group = create_add_sensor_section(self)
        form_layout.addRow(add_sensor_group)

        self.flight_type_combo = QComboBox()
        self.flight_type_combo.addItems(["Horizontal Flight (Nadir)", "Vertical/Facade Flight"])
        form_layout.addRow("1.2 Flight Type:", self.flight_type_combo)

        self.camera_orientation_combo = QComboBox()
        self.camera_orientation_combo.addItems(["Landscape", "Portrait"])
        form_layout.addRow("1.3 Camera Orientation:", self.camera_orientation_combo)

        group_box.setLayout(form_layout)
        return group_box

    def create_expandable_group(self, title, content_widget):
        container = QWidget()
        layout = QVBoxLayout(container)
        layout.setContentsMargins(0, 0, 0, 0)

        toggle_button = QToolButton()
        toggle_button.setStyleSheet("QToolButton { border: none; font-weight: bold; }")
        toggle_button.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
        toggle_button.setArrowType(Qt.RightArrow)
        toggle_button.setText(title)
        toggle_button.setCheckable(True)
        toggle_button.setChecked(False)

        frame = QFrame()
        frame.setLayout(QVBoxLayout())
        frame.layout().addWidget(content_widget)
        frame.setVisible(False)

        def toggle():
            visible = toggle_button.isChecked()
            frame.setVisible(visible)
            toggle_button.setArrowType(Qt.DownArrow if visible else Qt.RightArrow)

        toggle_button.clicked.connect(toggle)

        layout.addWidget(toggle_button)
        layout.addWidget(frame)
        return container

    def create_section_a(self):
        content = QWidget()
        layout = QFormLayout(content)
        self.focal_length_a = QLineEdit(); self.focal_length_a.setReadOnly(True)
        self.pixel_size_a = QLineEdit(); self.pixel_size_a.setReadOnly(True)
        self.altitude_a = QLineEdit()
        self.result_a = QLabel("Approx. GSD: -")
        self.altitude_a.textChanged.connect(self.calculate_gsd_a)
        layout.addRow("Focal length (mm):", self.focal_length_a)
        layout.addRow("Pixel size (µm):", self.pixel_size_a)
        layout.addRow("Flight Dist./Alt (m):", self.altitude_a)
        layout.addRow(self.result_a)
        return self.create_expandable_group("GSD Calculation (by pixel size)", content)

    def create_section_b(self):
        content = QWidget()
        layout = QFormLayout(content)
        self.sensor_width_b = QLineEdit(); self.sensor_width_b.setReadOnly(True)
        self.image_width_b = QLineEdit(); self.image_width_b.setReadOnly(True)
        self.focal_length_b = QLineEdit(); self.focal_length_b.setReadOnly(True)
        self.altitude_b = QLineEdit()
        self.result_b = QLabel("Approx. GSD: -")
        self.altitude_b.textChanged.connect(self.calculate_gsd_b)
        layout.addRow("Sensor width (mm):", self.sensor_width_b)
        layout.addRow("Image width (px):", self.image_width_b)
        layout.addRow("Focal length (mm):", self.focal_length_b)
        layout.addRow("Flight Dist./Alt. (m):", self.altitude_b)
        layout.addRow(self.result_b)
        return self.create_expandable_group("GSD Calculation (by sensor dimension)", content)

    def create_section_spacing(self):
        content = QWidget()
        layout = QFormLayout(content)
        self.sensor_width_spacing = QLineEdit(); self.sensor_width_spacing.setReadOnly(True)
        self.sensor_height_spacing = QLineEdit(); self.sensor_height_spacing.setReadOnly(True)
        self.focal_length_spacing = QLineEdit(); self.focal_length_spacing.setReadOnly(True)
        self.flight_height_spacing = QLineEdit()
        self.percentual_lat = QLineEdit()
        self.percentual_front = QLineEdit()
        self.result_spacing_lat = QLabel("Lateral Spacing: -")
        self.result_spacing_front = QLabel("Frontal Spacing: -")
        self.label_percentual_lat_spacing = QLabel("Desired Lateral Overlap (%):")
        self.label_percentual_front_spacing = QLabel("Desired Frontal Overlap (%):")
        layout.addRow("Sensor width (mm):", self.sensor_width_spacing)
        layout.addRow("Sensor height (mm):", self.sensor_height_spacing)
        layout.addRow("Focal length (mm):", self.focal_length_spacing)
        layout.addRow("Flight Height (m):", self.flight_height_spacing)
        layout.addRow(self.label_percentual_lat_spacing, self.percentual_lat)
        layout.addRow(self.label_percentual_front_spacing, self.percentual_front)
        layout.addRow(self.result_spacing_lat)
        layout.addRow(self.result_spacing_front)
        for field in [self.flight_height_spacing, self.percentual_lat, self.percentual_front]:
            field.textChanged.connect(self.calculate_spacing)
        return self.create_expandable_group("Ideal Spacing Calculation (by Overlap %)", content)

    def create_section_overlap(self):
        content = QWidget()
        layout = QFormLayout(content)
        self.sensor_width_overlap = QLineEdit(); self.sensor_width_overlap.setReadOnly(True)
        self.sensor_height_overlap = QLineEdit(); self.sensor_height_overlap.setReadOnly(True)
        self.focal_length_overlap = QLineEdit(); self.focal_length_overlap.setReadOnly(True)
        self.flight_height_overlap = QLineEdit()
        self.spacing_lines = QLineEdit()
        self.spacing_photos = QLineEdit()
        self.result_overlap_lateral = QLabel("Lateral Overlap: -")
        self.result_overlap_frontal = QLabel("Frontal Overlap: -")
        self.label_spacing_lines_overlap = QLabel("Spacing between Lines (m):")
        self.label_spacing_photos_overlap = QLabel("Spacing between Photos (m):")
        layout.addRow("Sensor width (mm):", self.sensor_width_overlap)
        layout.addRow("Sensor height (mm):", self.sensor_height_overlap)
        layout.addRow("Focal length (mm):", self.focal_length_overlap)
        layout.addRow("Flight Height (m):", self.flight_height_overlap)
        layout.addRow(self.label_spacing_lines_overlap, self.spacing_lines)
        layout.addRow(self.label_spacing_photos_overlap, self.spacing_photos)
        layout.addRow(self.result_overlap_lateral)
        layout.addRow(self.result_overlap_frontal)
        for field in [self.flight_height_overlap, self.spacing_lines, self.spacing_photos]:
            field.textChanged.connect(self.calculate_overlap)
        return self.create_expandable_group("Overlap Calculation (by Spacing)", content)

    def create_time_interval_section(self):
        content = QWidget()
        layout = QFormLayout(content)
        self.sensor_width_it = QLineEdit(); self.sensor_width_it.setReadOnly(True)
        self.focal_length_it = QLineEdit(); self.focal_length_it.setReadOnly(True)
        self.image_width_it = QLineEdit(); self.image_width_it.setReadOnly(True)
        self.image_height_it = QLineEdit(); self.image_height_it.setReadOnly(True)
        self.flight_height_it = QLineEdit()
        self.shutter_speed_it = QLineEdit()
        self.interval_it = QLineEdit()
        self.overlap_vertical_it = QLineEdit()
        self.result_gsd_it = QLabel("GSD: -")
        self.result_speed_max_it = QLabel("Max speed (blur): -")
        self.result_footprint_it = QLabel("Ground footprint: -")
        self.result_speed_overlap_it = QLabel("Speed for Overlap: -")
        layout.addRow("Sensor Width (mm):", self.sensor_width_it)
        layout.addRow("Focal Dist. (mm):", self.focal_length_it)
        layout.addRow("Image Width (px):", self.image_width_it)
        layout.addRow("Image Height (px):", self.image_height_it)
        layout.addRow("Flight Height (m):", self.flight_height_it)
        layout.addRow("Shutter Speed (1/x s, enter x):", self.shutter_speed_it)
        layout.addRow("Interval between photos (s):", self.interval_it)
        layout.addRow("Desired Flight Overlap (%):", self.overlap_vertical_it)
        layout.addRow(self.result_gsd_it)
        layout.addRow(self.result_speed_max_it)
        layout.addRow(self.result_footprint_it)
        layout.addRow(self.result_speed_overlap_it)
        for field in [self.flight_height_it, self.shutter_speed_it, self.interval_it, self.overlap_vertical_it]:
            field.textChanged.connect(self.calculate_flight_parameters)
        return self.create_expandable_group("Flight Parameters and Time Calculation", content)

    def _check_sensor_selected(self, input_fields_to_clear=None):
        if self.combo_drone.currentText().startswith("Select"):
            QMessageBox.warning(self, "Sensor Required", "Please select a sensor in 'Drone Model' to perform calculations.")
            if input_fields_to_clear:
                for field in input_fields_to_clear:
                    field.clear()
            return False
        return True

    def update_drone_fields(self, model_name):
        if model_name.startswith("Select"):
            for field in self.__dict__.values():
                if isinstance(field, QLineEdit): field.clear()
            self.settings.remove("GeoFlightPlanner/selected_sensor") # Clear the setting
            return
        
        self.settings.setValue("GeoFlightPlanner/selected_sensor", model_name)

        data = get_drone_feature(model_name)
        if not data:
            QMessageBox.warning(self, "Error", f"Drone model '{model_name}' not found.")
            return

        def set_field(field, key):
            field.setText(str(data.get(key, '')))

        set_field(self.focal_length_a, "focal_length"); set_field(self.pixel_size_a, "pixel_size")
        set_field(self.sensor_width_b, "sensor_width"); set_field(self.image_width_b, "image_width"); set_field(self.focal_length_b, "focal_length")
        set_field(self.sensor_width_spacing, "sensor_width"); set_field(self.sensor_height_spacing, "sensor_height"); set_field(self.focal_length_spacing, "focal_length")
        set_field(self.sensor_width_overlap, "sensor_width"); set_field(self.sensor_height_overlap, "sensor_height"); set_field(self.focal_length_overlap, "focal_length")
        set_field(self.sensor_width_it, "sensor_width"); set_field(self.focal_length_it, "focal_length"); set_field(self.image_width_it, "image_width"); set_field(self.image_height_it, "image_height")

    def update_calculation_logic_and_labels(self):
        is_horizontal = "Horizontal" in self.flight_type_combo.currentText()
        self.label_percentual_lat_spacing.setText("Desired Lateral Overlap (%):" if is_horizontal else "Horizontal Overlap between Photos (%):")
        self.label_percentual_front_spacing.setText("Desired Frontal Overlap (%):" if is_horizontal else "Vertical Overlap between Lines (%):")
        self.label_spacing_lines_overlap.setText("Spacing between Lines (m):" if is_horizontal else "Vertical Spacing between Lines (m):")
        self.label_spacing_photos_overlap.setText("Spacing between Photos (m):" if is_horizontal else "Horizontal Spacing between Photos (m):")
        self.calculate_spacing(); self.calculate_overlap()

    def calculate_gsd_a(self):
        if not self._check_sensor_selected([self.altitude_a]): return
        try:
            altitude = _get_numeric_value(self.altitude_a, "Altitude", allow_empty=True)
            if altitude is None: self.result_a.setText("Approx. GSD: -"); return
            gsd = calculate_gsd_by_pixel(self.combo_drone.currentText(), altitude)
            self.result_a.setText(f"Approx. GSD: {gsd:.2f} cm/pixel")
        except Exception as e: self.result_a.setText(f"Error: {e}")

    def calculate_gsd_b(self):
        if not self._check_sensor_selected([self.altitude_b]): return
        try:
            altitude = _get_numeric_value(self.altitude_b, "Altitude", allow_empty=True)
            if altitude is None: self.result_b.setText("Approx. GSD: -"); return
            gsd = calculate_gsd_by_sensor_dimension(self.combo_drone.currentText(), altitude)
            self.result_b.setText(f"Approx. GSD: {gsd:.2f} cm/pixel")
        except Exception as e: self.result_b.setText(f"Error: {e}")

    def calculate_spacing(self):
        if not self._check_sensor_selected([self.flight_height_spacing, self.percentual_lat, self.percentual_front]): return
        try:
            h = _get_numeric_value(self.flight_height_spacing, "Height", allow_empty=True)
            lat_ovl = _get_numeric_value(self.percentual_lat, "Overlap Lat.", allow_empty=True)
            front_ovl = _get_numeric_value(self.percentual_front, "Overlap Front.", allow_empty=True)
            if any(v is None for v in [h, lat_ovl, front_ovl]):
                self.result_spacing_lat.setText("Lateral Spacing: -"); self.result_spacing_front.setText("Frontal Spacing: -"); return
            
            result = calculate_spacing(
                drone_model=self.combo_drone.currentText(),
                flight_type=self.flight_type_combo.currentText(),
                camera_orientation=self.camera_orientation_combo.currentText(),
                flight_height=self.flight_height_spacing,
                lateral_percentage=self.percentual_lat,
                frontal_percentage=self.percentual_front,
                allow_empty=True
            )
            if result:
                self.result_spacing_lat.setText(result["lateral_spacing"])
                self.result_spacing_front.setText(result["frontal_spacing"])
            else:
                self.result_spacing_lat.setText("Lateral Spacing: -"); self.result_spacing_front.setText("Frontal Spacing: -")
        except Exception as e: 
            self.result_spacing_lat.setText(f"Error: {e}"); self.result_spacing_front.setText("")

    def calculate_overlap(self):
        if not self._check_sensor_selected([self.flight_height_overlap, self.spacing_lines, self.spacing_photos]): return
        try:
            h = _get_numeric_value(self.flight_height_overlap, "Height", allow_empty=True)
            line_space = _get_numeric_value(self.spacing_lines, "Line Spacing", allow_empty=True)
            photo_space = _get_numeric_value(self.spacing_photos, "Photo Spacing", allow_empty=True)
            if any(v is None for v in [h, line_space, photo_space]):
                self.result_overlap_lateral.setText("Lateral Overlap: -"); self.result_overlap_frontal.setText("Frontal Overlap: -"); return

            result = calculate_overlap(
                drone_model=self.combo_drone.currentText(),
                flight_type=self.flight_type_combo.currentText(),
                camera_orientation=self.camera_orientation_combo.currentText(),
                flight_height=self.flight_height_overlap,
                line_spacing=self.spacing_lines,
                photo_spacing=self.spacing_photos,
                allow_empty=True
            )
            if result:
                self.result_overlap_lateral.setText(result["lateral_overlap"])
                self.result_overlap_frontal.setText(result["frontal_overlap"])
            else:
                self.result_overlap_lateral.setText("Lateral Overlap: -"); self.result_overlap_frontal.setText("Frontal Overlap: -")
        except Exception as e: 
            self.result_overlap_lateral.setText(f"Error: {e}"); self.result_overlap_frontal.setText("")

    def calculate_flight_parameters(self):
        if not self._check_sensor_selected([self.flight_height_it, self.shutter_speed_it, self.interval_it, self.overlap_vertical_it]): return
        try:
            h = _get_numeric_value(self.flight_height_it, "Height", allow_empty=True)
            shutter = _get_numeric_value(self.shutter_speed_it, "Shutter", allow_empty=True)
            interval = _get_numeric_value(self.interval_it, "Interval", allow_empty=True)
            overlap = _get_numeric_value(self.overlap_vertical_it, "Overlap", allow_empty=True)
            if any(v is None for v in [h, shutter, interval, overlap]):
                self.result_gsd_it.setText("GSD: -"); self.result_speed_max_it.setText("Max speed (blur): -"); self.result_footprint_it.setText("Ground footprint: -"); self.result_speed_overlap_it.setText("Speed for Overlap: -")
                return

            params = calculate_flight_parameters(
                drone_model=self.combo_drone.currentText(),
                flight_height=self.flight_height_it,
                shutter_speed=self.shutter_speed_it,
                interval=self.interval_it,
                overlap=self.overlap_vertical_it,
                allow_empty=True
            )
            if params:
                self.result_gsd_it.setText(params['gsd'])
                self.result_speed_max_it.setText(params['max_speed_blur'])
                self.result_footprint_it.setText(params['footprint'])
                self.result_speed_overlap_it.setText(params['overlap_speed'])
            else:
                self.result_gsd_it.setText("GSD: -"); self.result_speed_max_it.setText("Max speed (blur): -"); self.result_footprint_it.setText("Ground footprint: -"); self.result_speed_overlap_it.setText("Speed for Overlap: -")
        except Exception as e: 
            self.result_gsd_it.setText(f"Error: {e}")

    def open_calculator_help(self):
        help_file_path = os.path.join(os.path.dirname(__file__), '..', 'docs', 'calculator.html')
        if os.path.exists(help_file_path):
            QDesktopServices.openUrl(QUrl.fromLocalFile(help_file_path))
        else:
            QMessageBox.warning(self, "Help", f"Help file not found: {help_file_path}")

    def closeEvent(self, event):
        self.hide()
        event.ignore()